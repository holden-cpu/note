[(六)漫谈分布式之一致性算法上篇：用二十六张图一探Raft共识算法奥妙之处！Raft共识算法，是分布式领域中不可或缺的一 - 掘金 (juejin.cn)](https://juejin.cn/post/7365833245956866083)

- [一、Raft协议的基本概述](https://juejin.cn/post/7365833245956866083#heading-1)

  - [1.1、问题分解](https://juejin.cn/post/7365833245956866083#heading-2)
  - [1.2、状态简化](https://juejin.cn/post/7365833245956866083#heading-3)
  - [1.3、复制状态机](https://juejin.cn/post/7365833245956866083#heading-4)
  - [1.4、Raft角色与转变](https://juejin.cn/post/7365833245956866083#heading-5)

- [二、Raft领导者选举（Leader Election）](https://juejin.cn/post/7365833245956866083#heading-6)

  - [2.1、Raft心跳机制](https://juejin.cn/post/7365833245956866083#heading-7)
  - [2.2、Raft选举过程](https://juejin.cn/post/7365833245956866083#heading-8)
    - [2.2.1、集群启动选举过程](https://juejin.cn/post/7365833245956866083#heading-9)
    - [2.2.2、Leader掉线选举过程](https://juejin.cn/post/7365833245956866083#heading-12)
  - [2.3、Raft选举小结](https://juejin.cn/post/7365833245956866083#heading-16)

- [三、Raft日志复制（Log Replication）](https://juejin.cn/post/7365833245956866083#heading-17)

  - [3.1、日志复制过程](https://juejin.cn/post/7365833245956866083#heading-18)
  - [3.2、Raft日志复制动画过程](https://juejin.cn/post/7365833245956866083#heading-19)
  - [3.3、Raft的一致性保证](https://juejin.cn/post/7365833245956866083#heading-20)

- [四、Raft小结](https://juejin.cn/post/7365833245956866083#heading-21)

  ---

  

- [一、日志复制的一致性隐患](https://juejin.cn/post/7365793739891163136#heading-0)

  - [1.1、日志不一致场景分析](https://juejin.cn/post/7365793739891163136#heading-1)
  - [1.2、Raft如何解决一致性隐患？](https://juejin.cn/post/7365793739891163136#heading-2)

- [二、Raft安全性（Safety）](https://juejin.cn/post/7365793739891163136#heading-3)

  - [2.1、选举机制的安全性保障](https://juejin.cn/post/7365793739891163136#heading-4)
  - [2.2、日志复制的安全性保障](https://juejin.cn/post/7365793739891163136#heading-5)
  - [2.3、领导者选举时的细节问题](https://juejin.cn/post/7365793739891163136#heading-6)

- [三、Raft日志压缩机制](https://juejin.cn/post/7365793739891163136#heading-7)

  - [3.1、什么是日志压缩？](https://juejin.cn/post/7365793739891163136#heading-8)
  - [3.2、Raft快照技术](https://juejin.cn/post/7365793739891163136#heading-9)

- [四、Raft动态伸缩机制](https://juejin.cn/post/7365793739891163136#heading-10)

  - [4.1、集群成员变更造成的脑裂问题](https://juejin.cn/post/7365793739891163136#heading-11)
  - [4.2、Raft的联合共识变更机制](https://juejin.cn/post/7365793739891163136#heading-12)
  - [4.3、Joint Consensus为什么能避免脑裂？](https://juejin.cn/post/7365793739891163136#heading-13)

- [五、Raft算法总结](https://juejin.cn/post/7365793739891163136#heading-14)

  ---

  

- [一、Raft协议的基本概述](https://juejin.cn/post/7365833245956866083#heading-1)

  - `Raft`本质是基于“状态机”工作的一种算法
  - [1.1、问题分解](https://juejin.cn/post/7365833245956866083#heading-2)
    - **领导者选举（Leader Election）**
    - **日志复制（Log Replication）**
    - **安全性（Safety）**
  - [1.2、状态简化](https://juejin.cn/post/7365833245956866083#heading-3)
    - `Raft`算法通过选举出`Leader`节点，**从而将`Paxos`的`Proposer`角色固化在一个节点上**，在运行期间内，只允许一个节点发出提案，剩余节点只能被动接受、学习提案
    - **`Raft`只需要考虑选举期间发生的角色切换，而不需要像`Paxos`那样考虑多种角色的共存和互相造成的影响**
  - [1.3、复制状态机](https://juejin.cn/post/7365833245956866083#heading-4)
    - `Replicated State Machine`复制状态机是一种抽象的概念，主要目的是用于确保分布式系统中各节点其副本状态的一致性。`Raft`复制状态机由多个复制单元组成，每个复制单元存储一个包含一系列指令的日志
    - `Raft`中的复制状态机，即是指将`Leader`节点的状态机，应用到所有复制单元（每个节点）
    - **只要实现了复制状态机，就能够保证分布式系统的数据一致性，客户端不管从哪个节点读取，都能看到相同的结果**
  - [1.4、Raft角色与转变](https://juejin.cn/post/7365833245956866083#heading-5)
    - `Leader`领导者、`Follower`追随者、`Candidate`候选者
    - **`Follower`追随者本身并不具备处理任何客户端请求的能力，当`Follower`接收到外部请求时，会将客户端请求重定向到`Leader`处理**

- [二、Raft领导者选举（Leader Election）](https://juejin.cn/post/7365833245956866083#heading-6)

  - 在`Raft`协议中，心跳包、日志复制、拉票/投票等消息的传递，都依赖`RPC`来做通信，主要分为两大类：
    - `RequestVote RPC`：用于选举阶段的拉票/投票通信；
    - `AppendEntries RPC`：用于存在`Leader`时期的日志复制、发送心跳。
  - [2.1、Raft心跳机制](https://juejin.cn/post/7365833245956866083#heading-7)
    - `Raft`中的心跳包只能由`Leader`发出，作用主要有两点，**其一是帮助`Leader`节点维持领导者地位**。**其二是帮助`Leader`确认其他节点的状态**
    - `Raft`给每个节点加了随机计时器，**当一个节点的计时器走完时，依旧未收到心跳包，就会转变成`Candidate`开始拉票。`Raft`接受多个`Candidate`同时拉票，但只允许一轮选举中只有一个节点胜出**。`Raft`的一轮任期只会存在一个`Leader`，当出现票数过于分散的场景时，允许一轮没有`Leader`的`term`存在
  - [2.2、Raft选举过程](https://juejin.cn/post/7365833245956866083#heading-8)
    - [2.2.1、集群启动选举过程](https://juejin.cn/post/7365833245956866083#heading-9)
      - 集群节点数都推荐奇数。在同一轮选举出现两个候选人的情况下，可以避免相互僵持的局面发生，保证一轮就能选出`Leader`节点。
      - **当集群节点的进度条走完时，如果还未收到心跳，它就会认为`Leader`离线，而后转变成`Candidate`节点，投自己一票并开始拉票**。`S2`发现领导者离线，先从追随者转变为候选人，接着自增自身的任期编号，然后投自己一票，最后向集群其他节点发出`RequestVote-RPC`，在该`RPC`对应的数据包里，会携带`S2`自增后的任期编号（`2`）
      - 随着拉票的`RPC`到达`S3`节点，`S3`节点会先对比`RPC`里携带的任期编号，如果比自身的编号要大，说明发出`RPC`的`S2`节点，**其任期要比自己新，`S3`就会将自己的票投给`S2`，同时将自身的任期编号更新成`2`，并重置自己的计时器（再次获取一个固定范围内的随机超时时间）**。
      - `S2`收到半数节点以上的投票后，就说明它获得了大多数节点的“拥戴”。观察上图，`S2`从`Candidate`转变成了`Leader`节点；同时，它又发出了四个橙色箭头，这就是成为`Leader`后发出的心跳包，**`S2`会依靠心跳维持自己的领导地位，避免其余节点再次开启新一轮选举**
    - [2.2.2、Leader掉线选举过程](https://juejin.cn/post/7365833245956866083#heading-12)
      - 当`Follower`节点回复一次心跳后，计数器走完还未收到下一次心跳，这时对应的节点就会认为`Leader`掉线，从而发起新一轮的选举。
      - **每个节点在发出`RPC`时，都会携带自身的任期编号**。`S5`发出心跳会带上自己的编号`3`，当旧主`S2`收到心跳后，一对比自身的编号，发现自己是`2`，就会认识到自己处于“过期的`Term`”，于是，就会将自身编号改为对方的编号，并改变身份成为对方的追随者
  - [2.3、Raft选举小结](https://juejin.cn/post/7365833245956866083#heading-16)
    - 核心**一是发现`Leader`离线，二是票选出新`Leader`**。当一个节点开始拉票后，能够出现的结果就三种：
      - 胜出：收到大多数节点的投票，成为新`Leader`；
      - 平局：多个节点一起拉票，导致票数分散，开启下一轮选举；
      - 失败：在自己之前有其他节点成为了新`Leader`，收到对方`RPC`后转变成追随者。

- [三、Raft日志复制（Log Replication）](https://juejin.cn/post/7365833245956866083#heading-17)

  - `Leader`节点上任后，除开要定期向集群发出心跳外，更重要是承接并处理客户端的操作，然后将其同步给集群其他`Follower`节点。为了实现同步状态机，`Leader`会把所有客户端的操作（一般泛指写操作），封装成`Log`并加入自己的日志序列，然后再将`Log`同步给所有`Follower`节点。**因为`Log`决定着集群的一致性，所以`Raft`只允许日志从`Leader`流向`Follower`节点**，从而避免`Paxos`那种并发提案冲突造成的不一致现象。
  - 日志只能从`Leader`流向`Follower`，客户端如何知道`Leader`是谁
    - 轮询方案：客户端每次执行写操作时，遍历所有节点，能操作成功就是`Leader`；
    - 重定向方案：集群实现重定向方案，当操作发到`Follower`时，就重定向到最新的`Leader`；
    - 健康检查方案：客户端定期向集群发起一次探测，在客户端维护最新的`Leader`地址。
  - [3.1、日志复制过程](https://juejin.cn/post/7365833245956866083#heading-18)
    - 当一个写操作抵达`S2`（`Leader`）后，`S2`会将该操作封装成`Log-Entry`（日志条目），并加入到自身的日志序列，然后会通过`AppendEntries-RPC`发往集群其余节点，其他节点收到`RPC`后，也会将`Log`加入到各自的日志序列，同时给`Leader`返回响应。
    - 当`Leader`收到集群大多数节点的响应后，意味着客户端本次操作对应的`Log`已同步至大部分节点，于是，`Leader`会将该日志应用（`Apply`）到自身的状态机，即把数据写入到当前节点，最后身为领导者的`S2`就会向客户端返回“操作成功”。
    - ，客户端的操作会被封装成`Log-Entry`，**但`Log`除开包含客户端的操作外，还会包含当前的任期编号，以及一个在日志序列里唯一的索引下标（日志号）**。通过任期号+日志下标，可以表示图中任何一个日志
    - **当`Log`同步给大多数`Follower`节点后，`Leader`会将对应的日志应用于自身状态机，接着向客户端返回操作成功**。而这些成功返回的客户端操作，对应的日志则视为“已提交日志”
  - [3.2、Raft日志复制动画过程](https://juejin.cn/post/7365833245956866083#heading-19)
    - 集群中唯一能确认`Log`是否可提交的节点是`Leader`，因此，`Follower`节点必须接收到`Leader`的通知后，才能将前面同步的`Log`应用于状态机（`commit`），可`Leader`何时会告知`Follower`节点可以提交日志呢
    - 在`Leader`发出的心跳`RPC`中，就会塞进一个额外的信息：**`Leader`上已应用于状态机的日志索引，即`S5`节点已提交（`Committed`）的日志索引**
    - `Raft`日志复制的完整流程：**第一阶段将客户端的操作先封装成`Log`，而后同步给所有节点并追加到序列；第二阶段再让所有`Follower`节点`Apply`前面复制的日志**。
  - [3.3、Raft的一致性保证](https://juejin.cn/post/7365833245956866083#heading-20)
    - 网络总是不可靠的，不同节点间的网络状况不同，任意时刻、任意节点都可能会发生延迟、丢包、故障、分区、乱序等问题。
    - 为了解决这类问题，**`Raft`要求`Leader`在发出`AppendEntries-RPC`时，需要额外附带上一条日志的`term，index`，如果`Follower`收到`RPC`后，在本地找不到相同的`term，index`，则会拒绝接收这次`RPC`**
    - 通过这种机制，只要`Follower`没有陷入故障状态，通过不断归纳验证，就一定能和`Leader`的日志序列保持一致，因此，`Raft`也能保证：**不同节点日志序列的某个日志（`term，index`）相同，那么在此之前的所有日志也全部相同**

- [一、日志复制的一致性隐患](https://juejin.cn/post/7365793739891163136#heading-0)

  - [1.1、日志不一致场景分析](https://juejin.cn/post/7365793739891163136#heading-1)
  - [1.2、Raft如何解决一致性隐患？](https://juejin.cn/post/7365793739891163136#heading-2)
    - 当集群节点出现日志序列不一致问题时，**`Raft`会强制要求存在不一致的`Follower`节点，直接复制在任`Leader`的日志序列来保持一致性**！
    - 当新`Leader`上任后，发现集群存在与自身序列不一致的`Follower`节点时，会使用自身序列中的日志，覆盖掉`Follower`节点中不一致的日志（`Leader`从不会丢弃自己序列里的日志）
    - `Leader`针对每个`Follower`节点，都会维护一个索引，即`Next-Index`，从其命名也能轻易得知其作用，就是用来记录下一个要发往`Follower`的日志下标，在`Leader`刚上任时，`Next-Index`默认为自己最后一个日志的下标加一。结合前面聊到的一致性检查机制，当集群存在不一致的`Follower`时，`Leader`发出的`AppendEntries-RPC`就无法通过一致性检查，此时`Leader`上维护的对应`Next-Index`会减一，经过不断归纳验证，总能找到两者最后达成一致的日志位置，接着会将之后所有不一致的`Log`全部覆盖。当然，碰到极端场景，`Next-Index`可能会变成`1`，即`Follower`上的所有日志都需要重新复制。

- [二、Raft安全性（Safety）](https://juejin.cn/post/7365793739891163136#heading-3)

  - [2.1、选举机制的安全性保障](https://juejin.cn/post/7365793739891163136#heading-4)
    - **Candidate发出RequestVote-RPC拉票时，必须携带自己本地序列中最新的日志（term，index），当其他Follower收到对应的拉票请求时，对比其携带的日志，如果发现该日志还没有自己的新，则会拒绝给该候选人投票**
    - **如果任期号（`term`）不同，任期号越大的日志越新；如果任期号相同。日志号（`index`）越大的越新**。
    - **做领导者选举时，只要一条日志被复制到了大多数节点，那么这些已提交的日志，在选举出来的新Leader上就一定存在，这也是Raft为何能保证日志一旦提交，就一定会被`Apply`到状态机、且永远不会丢失的原因**
  - [2.2、日志复制的安全性保障](https://juejin.cn/post/7365793739891163136#heading-5)
    - **Leader只允许提交（Commit）包含当前任期的日志**
  - [2.3、领导者选举时的细节问题](https://juejin.cn/post/7365793739891163136#heading-6)
    - 目前由`S1、S2、S3、S4、S5`五个节点组成集群，现任`Leader`是`S5`，`S5`如果在发出心跳后，由于`S2`节点网络较差，导致接收心跳包出现延迟，从而造成`S2`的随机选举时间出现超时，然后发起一轮新选举怎么办？
    - `S2、S5`之间的网络存在波动、不稳定导致的，`S2`就将正常的`S5`节点挤下线。如果是`S2`自身的网络一直存在问题，比如网络带宽延迟较高，网络传输速度不够稳定等等，那么它肯定不会有机会当选`Leader`！为啥？**因为网络存在问题的节点，永远不可能具备最新的日志**

- [三、Raft日志压缩机制](https://juejin.cn/post/7365793739891163136#heading-7)

  - [3.1、什么是日志压缩？](https://juejin.cn/post/7365793739891163136#heading-8)
    - **依靠`Snapshot`快照技术**
    - **快照就是将系统某一时刻的状态`Dump`下来，在此之前的所有操作日志都可以舍弃**
  - [3.2、Raft快照技术](https://juejin.cn/post/7365793739891163136#heading-9)
    - `Raft`并不会用快照反向生成日志序列，而是只留存快照文件、丢弃生成快照之前的日志
    - 一个快照文件中包含两种信息：
      - ①生成快照时，当前`Leader`节点的状态机（数据）；
      - ②生成快照时，最后一条被应用于状态机的日志元数据（`term、index`）。？
    - 通过另一种新的`InstallSnapshot-RPC`来实现。

- [四、Raft动态伸缩机制](https://juejin.cn/post/7365793739891163136#heading-10)

  - **也就是将集群成员变更的信息，也封装成一种特殊的日志（`Configuration Log Entry`），再由`Leader`同步给集群原本的其他节点**

  - [4.1、集群成员变更造成的脑裂问题](https://juejin.cn/post/7365793739891163136#heading-11)

    - **所谓脑裂，即是指中心化的集群中，同一时刻出现了两个`Leader/Master`节点**
    - **因为成员变更也需要依靠日志同步机制，来告知给所有的Follower节点**，而日志同步需要借助网络发送RPC，所以旧集群中的所有节点，不可能在同一时刻共同感知集群成员发生了变更。正因如此，在`Follower`同步成员变更日志这个期间，就可能会存在“不同节点看到的集群配置（视图）不一样”的情况，如果这期间`Leader`发生故障，或许就会引发脑裂情况发生。

  - [4.2、Raft的联合共识变更机制](https://juejin.cn/post/7365793739891163136#heading-12)

    - **任何直接将集群从`C-old`（旧配置）直接切换成`C-new`新配置的方式都不可靠**

    - 阶段一：由`Leader`先将发生集群成员变更的消息通知给所有节点；

      - ①客户端触发成员变更动作，先将`C-new`发给`Leader`节点，`Leader`在`C-old、C-new`两组配置中取并集，表示为`C-old,new`；

        ②`Leader`将新旧两组集群配置的并集`C-old,new`，封装成特殊的日志同步给所有`Follower`节点；

        ③当大多数`Follower`收到并集后，`Leader`将该并集对应的日志提交。

    - 阶段二：等大多数节点都收到成员变更的消息后，再正式切换到新的集群配置。

      - ①`C-old,new`的日志提交后，`Leader`继续将`C-new`封装为日志同步给所有`Follower`节点；

        ②一个`Follower`收到`C-new`后，如果发现自己不在`C-new`集合中，就主动从集群中退出；

        ③当大多数节点都将`C-new`同步完成后，代表集群正式切换到新配置，`Leader`向客户端返回变更成功。

  - [4.3、Joint Consensus为什么能避免脑裂？](https://juejin.cn/post/7365793739891163136#heading-13)

- [五、Raft算法总结](https://juejin.cn/post/7365793739891163136#heading-14)

# 一、Raft协议的基本概述

共识算法，Paxos算法几乎就是所有共识算法的根儿，它即可以保证分布式系统中的一致性，又能保证在小部分节点（半数减一）发生故障时，系统依旧能够正常对外服务。
可由于Paxos算法实在难以理解，Raft横空出世。
沿用了Multi-Paxos单Proposer的思想，保证了运行期间内只会存在一个Leader节点，而且是强Leader模式，**宁愿让系统没有Leader陷入瘫痪，也不允许出现脑裂现象，对外服务的任意时刻都只能存在一个Leader**。



# 问题分解

领导者选举（Leader Election），只有时刻保证Leader节点的可靠性，才能让Raft集群正常处理外部请求。
要实现集群副本之间的一致性，只需要将主节点上的数据操作，同步给集群内其他节点即可，而这就是Raft算法第二个核心问题：日志复制（Log Replication）
Raft在做领导者选举、日志复制时，必须要有一定的限制，这对应着Raft算法第三个核心问题：安全性（Safety）。

## 状态简化

Raft算法通过选举出Leader节点，从而将Paxos的Proposer角色固化在一个节点上，在运行期间内，只允许一个节点发出提案，剩余节点只能被动接受、学习提案
在同一时刻，Raft集群的各节点会固化一种角色，即一个节点只会属于Leader、Follower、Candidate其中一种角色！相较于Paxos，这种模式就极大程度上减少了算法的状态数量，及可能产生的状态变动，毕竟Raft只需要考虑选举期间发生的角色切换，而不需要像Paxos那样考虑多种角色的共存和互相造成的影响

## 复制状态机

Raft本质是基于“状态机”工作的一种算法。Replicated State Machine复制状态机是一种抽象的概念，主要目的是用于确保分布式系统中各节点其副本状态的一致性。Raft复制状态机由多个复制单元组成，每个复制单元存储一个包含一系列指令的日志。
当客户端向Raft服务集群发起请求时，Raft会将对应的操作封装成日志（Log），如果存在多个操作，则会将不同的操作封装成一个个Entry节点放入到日志里
Raft中的复制状态机，即是指将Leader节点的状态机，应用到所有复制单元（每个节点）上，在分布式系统中：如果一开始所有节点的副本数据都一致（状态相同），执行同样的操作指令后，最终的副本状态肯定也一致。

## Raft角色与转变

Leader领导者：负责处理客户端的所有操作，并将操作封装成日志同步给集群其他节点；
Follower追随者：负责接收Leader节点封装好的日志，并应用于自身的状态机里；
Candidate候选者：当集群中没有Leader节点时，追随者会转变成候选者，尝试成为新Leader。
Follower追随者本身并不具备处理任何客户端请求的能力，当Follower接收到外部请求时，会将客户端请求重定向到Leader处理
一轮新的选举，都被称为一个任期，每个term都有一个唯一标识来区分，这个标识就叫做任期编号，并且与Paxos的提案编号具备相同属性，必须要保证严格的递增性！即第二轮选举对应的任期编号，一定会大于第一轮选举的任期编号。集群启动会触发第一轮选举，对应的任期编号为1，选举的过程也不难理解，当一个Follower节点发现没有Leader存在时，自己会转变为Candidate节点，先投自己一票，接着向其他节点发起拉票请求，如果得到了大多数节点（半数以上）的节点支持，此Follower节点就会成为本轮任期中的Leader节点。
Follower是如何感知到没有Leader存在的？
Candidate是怎么向其他节点拉票的？
如果多个Follower一起转变成Candidate拉票怎么办？
新Leader上线，其他节点是如何成为其追随者的？

## Raft领导者选举（Leader Election）

心跳机制建立在通信的基础之上，所以Raft也是一种基于消息传递的共识算法。
在Raft协议中，心跳包、日志复制、拉票/投票等消息的传递，都依赖RPC来做通信，主要分为两大类：
RequestVote RPC：用于选举阶段的拉票/投票通信；
AppendEntries RPC：用于存在Leader时期的日志复制、发送心跳。
Raft依托这两类RPC完成集群工作，不管是哪类RPC，在通信时都会携带自己的任期编号，通过附带的任期号，就能将所有节点收敛到一致状态，如Leader、Candidate收到一个RPC时，发现大于自己的编号，说明自身处于过期的任期中，此时就会自动转变到Follower角色。

## Raft心跳机制

Raft中的心跳包只能由Leader发出，作用主要有两点，其一是帮助Leader节点维持领导者地位，持续向集群内宣布自己还“活着”，防止其他节点再次发起新一轮的选举；其二是帮助Leader确认其他节点的状态，如果某个节点收到心跳包后未作回复，Leader就会认为该节点已下线或陷入故障了
当一个节点的计时器走完时，依旧未收到心跳包，就会转变成Candidate开始拉票。一轮任期在规定时间内，还未票选出Leader节点，就会开始下一轮term！
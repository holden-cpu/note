# 常用函数

### MySQL 数值型函数

| 函数名称        | 作 用                                                      |
| :-------------- | :--------------------------------------------------------- |
| abs             | 求绝对值                                                   |
| sqrt            | 求二次方根                                                 |
| mod             | 求余数                                                     |
| ceil 和 ceiling | 两个函数功能相同，都是返回不小于参数的最小整数，即向上取整 |
| floor           | 向下取整，返回值转化为一个BIGINT                           |
| rand            | 生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列  |
| round           | 对所传参数进行四舍五入                                     |
| sign            | 返回参数的符号                                             |
| pow 和 power    | 两个函数的功能相同，都是所传参数的次方的结果值             |
| sin             | 求正弦值                                                   |
| asin            | 求反正弦值，与函数 SIN 互为反函数                          |
| cos             | 求余弦值                                                   |
| acos            | 求反余弦值，与函数 COS 互为反函数                          |
| tan             | 求正切值                                                   |
| atan            | 求反正切值，与函数 TAN 互为反函数                          |
| cot             | 求余切值                                                   |

#### abs:求绝对值

> 函数 ABS(x) 返回 x 的绝对值。正数的绝对值是其本身，负数的绝对值为其相反数，0 的绝对值是 0。

```java
mysql> select abs(5),abs(-2.4),abs(-24),abs(0);
+--------+-----------+----------+--------+
| abs(5) | abs(-2.4) | abs(-24) | abs(0) |
+--------+-----------+----------+--------+
|      5 |       2.4 |       24 |      0 |
+--------+-----------+----------+--------+
1 row in set (0.00 sec)
```

#### sqrt:求二次方跟（开方）

> 函数 SQRT(x) 返回非负数 x 的二次方根。负数没有平方根，返回结果为 NULL。

```
mysql> select sqrt(25),sqrt(120),sqrt(-9);
+----------+--------------------+----------+
| sqrt(25) | sqrt(120)          | sqrt(-9) |
+----------+--------------------+----------+
|        5 | 10.954451150103322 |     NULL |
+----------+--------------------+----------+
1 row in set (0.00 sec)
```

#### mod:求余数

> 函数 MOD(x,y) 返回 x 被 y 除后的余数，MOD() 对于带有小数部分的数值也起作用，它返回除法运算后的余数。

```
mysql> select mod(63,8),mod(120,10),mod(15.5,3);
+-----------+-------------+-------------+
| mod(63,8) | mod(120,10) | mod(15.5,3) |
+-----------+-------------+-------------+
|         7 |           0 |         0.5 |
+-----------+-------------+-------------+
1 row in set (0.00 sec)
```

#### ceil和ceiling:向上取整

> 函数 CEIL(x) 和 CEILING(x) 的意义相同，返回不小于 x 的最小整数值，返回值转化为一个 BIGINT。

```
mysql> select ceil(-2.5),ceiling(2.5);
+------------+--------------+
| ceil(-2.5) | ceiling(2.5) |
+------------+--------------+
|         -2 |            3 |
+------------+--------------+
1 row in set (0.00 sec)
```

#### floor:向下取整

> floor(x) 函数返回小于 x 的最大整数值。

```
mysql> select floor(5),floor(5.66),floor(-4),floor(-4.66);
+----------+-------------+-----------+--------------+
| floor(5) | floor(5.66) | floor(-4) | floor(-4.66) |
+----------+-------------+-----------+--------------+
|        5 |           5 |        -4 |           -5 |
+----------+-------------+-----------+--------------+
1 row in set (0.00 sec)
```

#### rand:生成一个随机数

> 生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列

```
mysql> select rand(), rand(), rand();
+--------------------+--------------------+--------------------+
| rand()             | rand()             | rand()             |
+--------------------+--------------------+--------------------+
| 0.5224735778965741 | 0.3678060549942833 | 0.2716095720153391 |
+--------------------+--------------------+--------------------+
1 row in set (0.00 sec)

mysql> select rand(1),rand(2),rand(1);
+---------------------+--------------------+---------------------+
| rand(1)             | rand(2)            | rand(1)             |
+---------------------+--------------------+---------------------+
| 0.40540353712197724 | 0.6555866465490187 | 0.40540353712197724 |
+---------------------+--------------------+---------------------+
1 row in set (0.00 sec)

mysql> select rand(1),rand(2),rand(1);
+---------------------+--------------------+---------------------+
| rand(1)             | rand(2)            | rand(1)             |
+---------------------+--------------------+---------------------+
| 0.40540353712197724 | 0.6555866465490187 | 0.40540353712197724 |
+---------------------+--------------------+---------------------+
1 row in set (0.00 sec)
```

#### round:四舍五入函数

> 返回最接近于参数 x 的整数；ROUND(x,y) 函数对参数x进行四舍五入的操作，返回值保留小数点后面指定的y位。

```
mysql> select round(-6.6),round(-8.44),round(3.44);
+-------------+--------------+-------------+
| round(-6.6) | round(-8.44) | round(3.44) |
+-------------+--------------+-------------+
|          -7 |           -8 |           3 |
+-------------+--------------+-------------+
1 row in set (0.00 sec)

mysql> select round(-6.66,1),round(3.33,3),round(88.66,-1),round(88.46,-2);
+----------------+---------------+-----------------+-----------------+
| round(-6.66,1) | round(3.33,3) | round(88.66,-1) | round(88.46,-2) |
+----------------+---------------+-----------------+-----------------+
|           -6.7 |         3.330 |              90 |             100 |
+----------------+---------------+-----------------+-----------------+
1 row in set (0.00 sec)
```

#### sign:返回参数的符号

> 返回参数的符号，x 的值为负、零和正时返回结果依次为 -1、0 和 1。

```
mysql> select sign(-6),sign(0),sign(34);
+----------+---------+----------+
| sign(-6) | sign(0) | sign(34) |
+----------+---------+----------+
|       -1 |       0 |        1 |
+----------+---------+----------+
1 row in set (0.00 sec)
```

#### pow 和 power:次方函数

> POW(x,y) 函数和 POWER(x,y) 函数用于计算 x 的 y 次方。

```
mysql> select pow(5,-2),pow(10,3),pow(100,0),power(4,3),power(6,-3);
+-----------+-----------+------------+------------+----------------------+
| pow(5,-2) | pow(10,3) | pow(100,0) | power(4,3) | power(6,-3)          |
+-----------+-----------+------------+------------+----------------------+
|      0.04 |      1000 |          1 |         64 | 0.004629629629629629 |
+-----------+-----------+------------+------------+----------------------+
1 row in set (0.00 sec)
```

#### sin:正弦函数

> SIN(x) 返回 x 的正弦值，其中 x 为弧度值。

```
mysql> select sin(1),sin(0.5*pi()),pi();
+--------------------+---------------+----------+
| sin(1)             | sin(0.5*pi()) | pi()     |
+--------------------+---------------+----------+
| 0.8414709848078965 |             1 | 3.141593 |
+--------------------+---------------+----------+
1 row in set (0.00 sec)
```

> 注：PI() 函数返回圆周率（3.141593）

**其他几个三角函数在此就不说了，有兴趣的可以自己去练习一下。**

### MySQL 字符串函数

| 函数名称            | 作 用                                                        |
| :------------------ | :----------------------------------------------------------- |
| length              | 计算字符串长度函数，返回字符串的字节长度                     |
| concat              | 合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个 |
| insert              | 替换字符串函数                                               |
| lower               | 将字符串中的字母转换为小写                                   |
| upper               | 将字符串中的字母转换为大写                                   |
| left                | 从左侧字截取符串，返回字符串左边的若干个字符                 |
| right               | 从右侧字截取符串，返回字符串右边的若干个字符                 |
| trim                | 删除字符串左右两侧的空格                                     |
| replace             | 字符串替换函数，返回替换后的新字符串                         |
| substr 和 substring | 截取字符串，返回从指定位置开始的指定长度的字符换             |
| reverse             | 字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串     |

#### length:返回字符串直接长度

> 返回值为字符串的字节长度，使用 uft8（UNICODE 的一种变长字符编码，又称万国码）编码字符集时，一个汉字是 3 个字节，一个数字或字母是一个字节。

```
mysql> select length('javacode2018'),length('路人甲Java'),length('路人');
+------------------------+-------------------------+------------------+
| length('javacode2018') | length('路人甲Java')    | length('路人')   |
+------------------------+-------------------------+------------------+
|                     12 |                      13 |                6 |
+------------------------+-------------------------+------------------+
1 row in set (0.00 sec)
```

#### concat:合并字符串

> CONCAT(sl，s2，…) 函数返回结果为连接参数产生的字符串，或许有一个或多个参数。
>
> 若有任何一个参数为 NULL，则返回值为 NULL。若所有参数均为非二进制字符串，则结果为非二进制字符串。若自变量中含有任一二进制字符串，则结果为一个二进制字符串。

```
mysql> select concat('路人甲','java'),concat('路人甲',null,'java');
+----------------------------+---------------------------------+
| concat('路人甲','java')    | concat('路人甲',null,'java')    |
+----------------------------+---------------------------------+
| 路人甲java                 | NULL                            |
+----------------------------+---------------------------------+
1 row in set (0.00 sec)
```

#### insert:替换字符串

> INSERT(s1，x，len，s2) 返回字符串 s1，子字符串起始于 x 位置，并且用 len 个字符长的字符串代替 s2。
>
> x的值从1开始，第一个字符的x=1，若 x 超过字符串长度，则返回值为原始字符串。
>
> 假如 len 的长度大于其他字符串的长度，则从位置 x 开始替换。
>
> 若任何一个参数为 NULL，则返回值为 NULL。

```
mysql> select
    ->   insert('路人甲Java', 2, 4, '**') AS col1,
    ->   insert('路人甲Java', -1, 4,'**') AS col2,
    ->   insert('路人甲Java', 3, 20,'**') AS col3;
+---------+---------------+----------+
| col1    | col2          | col3     |
+---------+---------------+----------+
| 路**va  | 路人甲Java    | 路人**   |
+---------+---------------+----------+
1 row in set (0.00 sec)
```

#### lower:将字母转换成小写

> LOWER(str) 可以将字符串 str 中的字母字符全部转换成小写。

```
mysql> select lower('路人甲JAVA');
+------------------------+
| lower('路人甲JAVA')    |
+------------------------+
| 路人甲java             |
+------------------------+
1 row in set (0.00 sec)
```

#### upper:将字母转换成大写

> UPPER(str) 可以将字符串 str 中的字母字符全部转换成大写。

```
mysql> select upper('路人甲java');
+------------------------+
| upper('路人甲java')    |
+------------------------+
| 路人甲JAVA             |
+------------------------+
1 row in set (0.00 sec)
```

#### left:从左侧截取字符串

> LEFT(s，n) 函数返回字符串 s 最左边的 n 个字符，s=1表示第一个字符。

```
mysql> select left('路人甲JAVA',2),left('路人甲JAVA',10),left('路人甲JAVA',-1);
+-------------------------+--------------------------+--------------------------+
| left('路人甲JAVA',2)    | left('路人甲JAVA',10)    | left('路人甲JAVA',-1)    |
+-------------------------+--------------------------+--------------------------+
| 路人                    | 路人甲JAVA               |                          |
+-------------------------+--------------------------+--------------------------+
1 row in set (0.00 sec)
```

#### right:从右侧截取字符串

> RIGHT(s，n) 函数返回字符串 s 最右边的 n 个字符。

```
mysql> select right('路人甲JAVA',1),right('路人甲JAVA',10),right('路人甲JAVA',-1);
+--------------------------+---------------------------+---------------------------+
| right('路人甲JAVA',1)    | right('路人甲JAVA',10)    | right('路人甲JAVA',-1)    |
+--------------------------+---------------------------+---------------------------+
| A                        | 路人甲JAVA                |                           |
+--------------------------+---------------------------+---------------------------+
1 row in set (0.00 sec)
```

#### trim:删除字符串两侧空格

> TRIM(s) 删除字符串 s 两侧的空格。

```
mysql> select '[   路人甲Java   ]',concat('[',trim('   路人甲Java   '),']');
+-----------------------+---------------------------------------------+
| [   路人甲Java   ]    | concat('[',trim('   路人甲Java   '),']')    |
+-----------------------+---------------------------------------------+
| [   路人甲Java   ]    | [路人甲Java]                                |
+-----------------------+---------------------------------------------+
1 row in set (0.00 sec)
```

#### replace:字符串替换

> REPLACE(s，s1，s2) 使用字符串 s2 替换字符串 s 中所有的字符串 s1。

#### substr 和 substring:截取字符串

> substr(str,pos)
>
> substr(str from pos)
>
> substr(str,pos,len)
>
> substr(str from pos for len)
>
> substr()是substring()的同义词。
>
> 没有len参数的形式是字符串str从位置pos开始返回一个子字符串。
>
> 带有len参数的形式是字符串str从位置pos开始返回长度为len的子字符串。
>
> 使用FROM的形式是标准的SQL语法。
>
> 也可以对pos使用负值，在这种情况下，子字符串的开头是字符串末尾的pos字符，而不是开头。在这个函数的任何形式中pos可以使用负值。
>
> 对于所有形式的substring()，从中提取子串的字符串中第一个字符的位置被认为是1。

```
/** 第三个字符之后的子字符串：inese **/
SELECT substring('chinese', 3);
/** 倒数第三个字符之后的子字符串：ese **/
SELECT substring('chinese', -3);
/** 第三个字符之后的两个字符：in **/
SELECT substring('chinese', 3, 2);
/** 倒数第三个字符之后的两个字符：es **/
SELECT substring('chinese', -3, 2);
/** 第三个字符之后的子字符串：inese **/
SELECT substring('chinese' FROM 3);
/** 倒数第三个字符之后的子字符串：ese **/
SELECT substring('chinese' FROM -3);
/** 第三个字符之后的两个字符：in **/
SELECT substring('chinese' FROM 3 FOR 2);
/** 倒数第三个字符之后的两个字符：es **/
SELECT substring('chinese' FROM -3 FOR 2);
```

#### reverse:反转字符串

> REVERSE(s) 可以将字符串 s 反转，返回的字符串的顺序和 s 字符串的顺序相反。

```
mysql> select reverse('路人甲Java');
+--------------------------+
| reverse('路人甲Java')    |
+--------------------------+
| avaJ甲人路               |
+--------------------------+
1 row in set (0.00 sec)
```

### MySQL 日期和时间函数

| 函数名称                | 作 用                                                        |
| :---------------------- | :----------------------------------------------------------- |
| curdate 和 current_date | 两个函数作用相同，返回当前系统的日期值                       |
| curtime 和 current_time | 两个函数作用相同，返回当前系统的时间值                       |
| now 和 sysdate          | 两个函数作用相同，返回当前系统的日期和时间值                 |
| unix_timestamp          | 获取UNIX时间戳函数，返回一个以 UNIX 时间戳为基础的无符号整数 |
| from_unixtime           | 将 UNIX 时间戳转换为时间格式，与UNIX_TIMESTAMP互为反函数     |
| month                   | 获取指定日期中的月份                                         |
| monthname               | 获取指定日期中的月份英文名称                                 |
| dayname                 | 获取指定曰期对应的星期几的英文名称                           |
| dayofweek               | 获取指定日期是一周中是第几天，返回值范围是1~7,1=周日         |
| week                    | 获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53 |
| dayofyear               | 获取指定曰期是一年中的第几天，返回值范围是1~366              |
| dayofmonth              | 获取指定日期是一个月中是第几天，返回值范围是1~31             |
| year                    | 获取年份，返回值范围是 1970〜2069                            |
| time_to_sec             | 将时间参数转换为秒数                                         |
| sec_to_time             | 将秒数转换为时间，与TIME_TO_SEC 互为反函数                   |
| date_add 和 adddate     | 两个函数功能相同，都是向日期添加指定的时间间隔               |
| date_sub 和 subdate     | 两个函数功能相同，都是向日期减去指定的时间间隔               |
| addtime                 | 时间加法运算，在原始时间上添加指定的时间                     |
| subtime                 | 时间减法运算，在原始时间上减去指定的时间                     |
| datediff                | 获取两个日期之间间隔，返回参数 1 减去参数 2 的值             |
| date_format             | 格式化指定的日期，根据参数返回指定格式的值                   |
| weekday                 | 获取指定日期在一周内的对应的工作日索引                       |

#### curdate 和 current_date:两个函数作用相同，返回当前系统的日期值

> CURDATE() 和 CURRENT_DATE() 函数的作用相同，将当前日期按照“YYYY-MM-DD”或“YYYYMMDD”格式的值返回，具体格式根据函数用在字符串或数字语境中而定，返回的`date`类型。

```
mysql> select curdate(),current_date(),current_date()+1;
+------------+----------------+------------------+
| curdate()  | current_date() | current_date()+1 |
+------------+----------------+------------------+
| 2019-09-17 | 2019-09-17     |         20190918 |
+------------+----------------+------------------+
1 row in set (0.00 sec)
```

#### curtime 和 current_time:获取系统当前时间

> CURTIME() 和 CURRENT_TIME() 函数的作用相同，将当前时间以“HH：MM：SS”或“HHMMSS”格式返回，具体格式根据函数用在字符串或数字语境中而定，返回`time`类型。

```
mysql> select curtime(),current_time(),current_time()+1;
+-----------+----------------+------------------+
| curtime() | current_time() | current_time()+1 |
+-----------+----------------+------------------+
| 16:11:25  | 16:11:25       |           161126 |
+-----------+----------------+------------------+
1 row in set (0.00 sec)
```

#### now 和 sysdate:获取当前时间日期

> NOW() 和 SYSDATE() 函数的作用相同，都是返回当前日期和时间值，格式为“YYYY-MM-DD HH：MM：SS”或“YYYYMMDDHHMMSS”，具体格式根据函数用在字符串或数字语境中而定，返回`datetime`类型。

```
mysql> select now(),sysdate();
+---------------------+---------------------+
| now()               | sysdate()           |
+---------------------+---------------------+
| 2019-09-17 16:13:28 | 2019-09-17 16:13:28 |
+---------------------+---------------------+
1 row in set (0.00 sec)
```

#### unix_timestamp:获取UNIX时间戳

> UNIX_TIMESTAMP(date) 若无参数调用，返回一个无符号整数类型的 UNIX 时间戳（'1970-01-01 00:00:00'GMT之后的秒数）。

```
mysql> select unix_timestamp(),unix_timestamp(now()),now(),unix_timestamp('2019-09-17 12:00:00');
+------------------+-----------------------+---------------------+---------------------------------------+
| unix_timestamp() | unix_timestamp(now()) | now()               | unix_timestamp('2019-09-17 12:00:00') |
+------------------+-----------------------+---------------------+---------------------------------------+
|       1568710893 |            1568710893 | 2019-09-17 17:01:33 |                            1568692800 |
+------------------+-----------------------+---------------------+---------------------------------------+
1 row in set (0.00 sec)
```

#### from_unixtime:时间戳转日期

> FROM_UNIXTIME(unix_timestamp[,format]) 函数把 UNIX 时间戳转换为普通格式的日期时间值，与 `UNIX_TIMESTAMP ()` 函数互为反函数。
>
> 有2个参数：
>
> unix_timestamp：时间戳（秒）
>
> format：要转化的格式 比如“”%Y-%m-%d“” 这样格式化之后的时间就是 2017-11-30
>
> 可以有的形式：

| 格式          | 说明                                         |
| :------------ | :------------------------------------------- |
| %M            | 月名字(January～December)                    |
| %W            | 星期名字(Sunday～Saturday)                   |
| %D            | 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等） |
| %Y            | 年, 数字, 4 位                               |
| %y            | 年, 数字, 2 位                               |
| %a            | 缩写的星期名字(Sun～Sat)                     |
| %d            | 月份中的天数, 数字(00～31)                   |
| %e            | 月份中的天数, 数字(0～31)                    |
| %m            | 月, 数字(01～12)                             |
| %c            | 月, 数字(1～12)                              |
| %b            | 缩写的月份名字(Jan～Dec)                     |
| %j            | 一年中的天数(001～366)                       |
| %H            | 小时(00～23)                                 |
| %k            | 小时(0～23)                                  |
| %h            | 小时(01～12)                                 |
| %I（i的大写） | 小时(01～12)                                 |
| %l（L的小写） | 小时(1～12)                                  |
| %i            | 分钟, 数字(00～59)                           |
| %r            | 时间,12 小时(hh:mm:ss [AP]M)                 |
| %T            | 时间,24 小时(hh:mm:ss)                       |
| %S            | 秒(00～59)                                   |
| %s            | 秒(00～59)                                   |
| %p            | AM或PM                                       |
| %W            | 一个星期中的天数英文名称(Sunday~Saturday）   |
| %w            | 一个星期中的天数(0=Sunday ～6=Saturday）     |
| %U            | 星期(0～52), 这里星期天是星期的第一天        |
| %u            | 星期(0～52), 这里星期一是星期的第一天        |
| %%            | 输出%                                        |

```
mysql> select from_unixtime(1568710866),from_unixtime(1568710866,'%Y-%m-%d %H:%h:%s');
+---------------------------+-----------------------------------------------+
| from_unixtime(1568710866) | from_unixtime(1568710866,'%Y-%m-%d %H:%h:%s') |
+---------------------------+-----------------------------------------------+
| 2019-09-17 17:01:06       | 2019-09-17 17:05:06                           |
+---------------------------+-----------------------------------------------+
1 row in set (0.00 sec)
```

#### month:获取指定日期的月份

> MONTH(date) 函数返回指定 date 对应的月份，范围为 1～12。

```
mysql> select month('2017-12-15'),month(now());
+---------------------+--------------+
| month('2017-12-15') | month(now()) |
+---------------------+--------------+
|                  12 |            9 |
+---------------------+--------------+
1 row in set (0.00 sec)
```

#### monthname:获取指定日期月份的英文名称

> MONTHNAME(date) 函数返回日期 date 对应月份的英文全名。

```
mysql> select monthname('2017-12-15'),monthname(now());
+-------------------------+------------------+
| monthname('2017-12-15') | monthname(now()) |
+-------------------------+------------------+
| December                | September        |
+-------------------------+------------------+
1 row in set (0.00 sec)
```

#### dayname:获取指定日期的星期名称

> DAYNAME(date) 函数返回 date 对应的工作日英文名称，例如 Sunday、Monday 等。

```
mysql> select now(),dayname(now());
+---------------------+----------------+
| now()               | dayname(now()) |
+---------------------+----------------+
| 2019-09-17 17:13:08 | Tuesday        |
+---------------------+----------------+
1 row in set (0.00 sec)
```

#### dayofweek:获取日期对应的周索引

> DAYOFWEEK(d) 函数返回 d 对应的一周中的索引（位置）。1 表示周日，2 表示周一，……，7 表示周六。这些索引值对应于ODBC标准。

```
mysql> select now(),dayofweek(now());
+---------------------+------------------+
| now()               | dayofweek(now()) |
+---------------------+------------------+
| 2019-09-17 17:14:21 |                3 |
+---------------------+------------------+
1 row in set (0.00 sec)
```

#### week:获取指定日期是一年中的第几周

> WEEK(date[,mode]) 函数计算日期 date 是一年中的第几周。WEEK(date,mode) 函数允许指定星期是否起始于周日或周一，以及返回值的范围是否为 0～52 或 1～53。
>
> WEEK函数接受两个参数：
>
> - `date`是要获取周数的日期。
> - `mode`是一个可选参数，用于确定周数计算的逻辑。它允许您指定本周是从星期一还是星期日开始，返回的周数应在`0`到`52`之间或`0`到`53`之间。
>
> 如果忽略`mode`参数，默认情况下`WEEK`函数将使用`default_week_format`系统变量的值。
>
> 要获取`default_week_format`变量的当前值，请使用`SHOW VARIABLES`语句如下：

```
mysql> SHOW VARIABLES LIKE 'default_week_format';
+---------------------+-------+
| Variable_name       | Value |
+---------------------+-------+
| default_week_format | 0     |
+---------------------+-------+
1 row in set, 1 warning (0.00 sec)
```

在我们的服务器中，`default_week_format`的默认值为`0`，下表格说明了`mode`参数如何影响`WEEK`函数：

| 模式 | 一周的第一天 | 范围 |
| :--- | :----------- | :--- |
| 0    | 星期日       | 0-53 |
| 1    | 星期一       | 0-53 |
| 2    | 星期日       | 1-53 |
| 3    | 星期一       | 1-53 |
| 4    | 星期日       | 0-53 |
| 5    | 星期一       | 0-53 |
| 6    | 星期日       | 1-53 |
| 7    | 星期一       | 1-53 |

上表中“今年有4天以上”表示：

- 如果星期包含1月1日，并且在新的一年中有`4`天或更多天，那么这周是第`1`周。
- 否则，这一周的数字是前一年的最后一周，下周是第1周。

```
mysql> select now(),week(now());
+---------------------+-------------+
| now()               | week(now()) |
+---------------------+-------------+
| 2019-09-17 17:20:28 |          37 |
+---------------------+-------------+
1 row in set (0.00 sec)
```

#### dayofyear:获取指定日期在一年中的位置

> DAYOFYEAR(d) 函数返回 d 是一年中的第几天，范围为 1～366。

```
mysql> select now(),dayofyear(now()),dayofyear('2019-01-01');
+---------------------+------------------+-------------------------+
| now()               | dayofyear(now()) | dayofyear('2019-01-01') |
+---------------------+------------------+-------------------------+
| 2019-09-17 17:22:00 |              260 |                       1 |
+---------------------+------------------+-------------------------+
1 row in set (0.00 sec)
```

#### dayofmonth:获取指定日期在一个月的位置

> DAYOFMONTH(d) 函数返回 d 是一个月中的第几天，范围为 1～31。

```
mysql> select now(),dayofmonth(now()),dayofmonth('2019-01-01');
+---------------------+-------------------+--------------------------+
| now()               | dayofmonth(now()) | dayofmonth('2019-01-01') |
+---------------------+-------------------+--------------------------+
| 2019-09-17 17:23:09 |                17 |                        1 |
+---------------------+-------------------+--------------------------+
1 row in set (0.00 sec)
```

#### year:获取年份

> YEAR() 函数可以从指定日期值中来获取年份值。

```
mysql> select now(),year(now()),year('2019-01-02');
+---------------------+-------------+--------------------+
| now()               | year(now()) | year('2019-01-02') |
+---------------------+-------------+--------------------+
| 2019-09-17 17:28:10 |        2019 |               2019 |
+---------------------+-------------+--------------------+
1 row in set (0.00 sec)
```

#### time_to_sec:将时间转换为秒值

> TIME_TO_SEC(time) 函数返回将参数 time 转换为秒数的时间值，转换公式为“小时 ×3600+ 分钟 ×60+ 秒”。

```
mysql> select time_to_sec('15:15:15'),now(),time_to_sec(now());
+-------------------------+---------------------+--------------------+
| time_to_sec('15:15:15') | now()               | time_to_sec(now()) |
+-------------------------+---------------------+--------------------+
|                   54915 | 2019-09-17 17:30:44 |              63044 |
+-------------------------+---------------------+--------------------+
1 row in set (0.00 sec)
```

#### sec_to_time:将秒值转换为时间格式

> SEC_TO_TIME(seconds) 函数返回将参数 seconds 转换为小时、分钟和秒数的时间值。

```
mysql> select sec_to_time(100),sec_to_time(10000);
+------------------+--------------------+
| sec_to_time(100) | sec_to_time(10000) |
+------------------+--------------------+
| 00:01:40         | 02:46:40           |
+------------------+--------------------+
1 row in set (0.00 sec)
```

#### date_add和adddate:向日期添加指定时间间隔

> DATE_ADD(date,INTERVAL expr type)
>
> date：参数是合法的日期表达式。*expr* 参数是您希望添加的时间间隔。
>
> type：参数可以是下列值

| Type 值            |
| :----------------- |
| MICROSECOND        |
| SECOND             |
| MINUTE             |
| HOUR               |
| DAY                |
| WEEK               |
| MONTH              |
| QUARTER            |
| YEAR               |
| SECOND_MICROSECOND |
| MINUTE_MICROSECOND |
| MINUTE_SECOND      |
| HOUR_MICROSECOND   |
| HOUR_SECOND        |
| HOUR_MINUTE        |
| DAY_MICROSECOND    |
| DAY_SECOND         |
| DAY_MINUTE         |
| DAY_HOUR           |
| YEAR_MONTH         |

```
mysql> select date_add('2019-01-01',INTERVAL 10 day),adddate('2019-01-01 16:00:00',interval 100 SECOND);
+----------------------------------------+----------------------------------------------------+
| date_add('2019-01-01',INTERVAL 10 day) | adddate('2019-01-01 16:00:00',interval 100 SECOND) |
+----------------------------------------+----------------------------------------------------+
| 2019-01-11                             | 2019-01-01 16:01:40                                |
+----------------------------------------+----------------------------------------------------+
1 row in set (0.00 sec)

mysql> select date_add('2019-01-01',INTERVAL -10 day),adddate('2019-01-01 16:00:00',interval -100 SECOND);
+-----------------------------------------+-----------------------------------------------------+
| date_add('2019-01-01',INTERVAL -10 day) | adddate('2019-01-01 16:00:00',interval -100 SECOND) |
+-----------------------------------------+-----------------------------------------------------+
| 2018-12-22                              | 2019-01-01 15:58:20                                 |
+-----------------------------------------+-----------------------------------------------------+
1 row in set (0.00 sec)
```

#### date_sub和subdate:日期减法运算

> DATE_SUB(date,INTERVAL expr type)
>
> date：参数是合法的日期表达式。*expr* 参数是您希望添加的时间间隔。
>
> type的类型和date_add中的type一样。

```
mysql> select date_sub('2019-01-01',INTERVAL 10 day),subdate('2019-01-01 16:00:00',interval 100 SECOND);
+----------------------------------------+----------------------------------------------------+
| date_sub('2019-01-01',INTERVAL 10 day) | subdate('2019-01-01 16:00:00',interval 100 SECOND) |
+----------------------------------------+----------------------------------------------------+
| 2018-12-22                             | 2019-01-01 15:58:20                                |
+----------------------------------------+----------------------------------------------------+
1 row in set (0.00 sec)

mysql> select date_sub('2019-01-01',INTERVAL -10 day),subdate('2019-01-01 16:00:00',interval -100 SECOND);
+-----------------------------------------+-----------------------------------------------------+
| date_sub('2019-01-01',INTERVAL -10 day) | subdate('2019-01-01 16:00:00',interval -100 SECOND) |
+-----------------------------------------+-----------------------------------------------------+
| 2019-01-11                              | 2019-01-01 16:01:40                                 |
+-----------------------------------------+-----------------------------------------------------+
1 row in set (0.00 sec)
```

#### addtime:时间加法运算

> ADDTIME(time,expr) 函数用于执行时间的加法运算。添加 expr 到 time 并返回结果。
>
> 其中：time 是一个时间或日期时间表达式，expr 是一个时间表达式。

```
mysql> select addtime('2019-09-18 23:59:59','0:1:1'), addtime('10:30:59','5:10:37');
+----------------------------------------+-------------------------------+
| addtime('2019-09-18 23:59:59','0:1:1') | addtime('10:30:59','5:10:37') |
+----------------------------------------+-------------------------------+
| 2019-09-19 00:01:00                    | 15:41:36                      |
+----------------------------------------+-------------------------------+
1 row in set (0.00 sec)
```

#### subtime:时间减法运算

> SUBTIME(time,expr) 函数用于执行时间的减法运算。
>
> 函数返回 time。expr 表示的值和格式 time 相同。time 是一个时间或日期时间表达式， expr 是一个时间。

```
mysql> select subtime('2019-09-18 23:59:59','0:1:1'),subtime('10:30:59','5:12:37');
+----------------------------------------+-------------------------------+
| subtime('2019-09-18 23:59:59','0:1:1') | subtime('10:30:59','5:12:37') |
+----------------------------------------+-------------------------------+
| 2019-09-18 23:58:58                    | 05:18:22                      |
+----------------------------------------+-------------------------------+
1 row in set (0.00 sec)
```

#### datediff:获取两个日期的时间间隔

> DATEDIFF(date1，date2) 返回起始时间 date1 和结束时间 date2 之间的天数。date1 和 date2 为日期或 date-and-time 表达式。计算时只用到这些值的日期部分。

```
mysql> select datediff('2017-11-30','2017-11-29') as col1, datediff('2017-11-30','2017-12-15') as col2;
+------+------+
| col1 | col2 |
+------+------+
|    1 |  -15 |
+------+------+
1 row in set (0.00 sec)
```

#### date_format:格式化指定的日期

> DATE_FORMAT(date，format) 函数是根据 format 指定的格式显示 date 值。
>
> DATE_FORMAT() 函数接受两个参数：
>
> date：是要格式化的有效日期值format：是由预定义的说明符组成的格式字符串，每个说明符前面都有一个百分比字符(%)。
>
> format：格式和上面的函数`from_unixtime`中的format一样，可以参考上面的。

```
mysql> select date_format('2017-11-30','%Y%m%d') as col0,now() as col1, date_format(now(),'%Y%m%d%H%i%s') as col2;
+----------+---------------------+----------------+
| col0     | col1                | col2           |
+----------+---------------------+----------------+
| 20171130 | 2019-09-17 17:56:12 | 20190917175612 |
+----------+---------------------+----------------+
1 row in set (0.00 sec)
```

#### weekday:获取指定日期在一周内的索引位置

> WEEKDAY(date) 返回date的星期索引(0=星期一，1=星期二, ……6= 星期天)。

```
mysql> select now(),weekday(now());
+---------------------+----------------+
| now()               | weekday(now()) |
+---------------------+----------------+
| 2019-09-17 18:01:34 |              1 |
+---------------------+----------------+
1 row in set (0.00 sec)

mysql> select now(),dayofweek(now());
+---------------------+------------------+
| now()               | dayofweek(now()) |
+---------------------+------------------+
| 2019-09-17 18:01:34 |                3 |
+---------------------+------------------+
1 row in set (0.00 sec)
```

### MySQL 聚合函数

| 函数名称 | 作用                             |
| :------- | :------------------------------- |
| max      | 查询指定列的最大值               |
| min      | 查询指定列的最小值               |
| count    | 统计查询结果的行数               |
| sum      | 求和，返回指定列的总和           |
| avg      | 求平均值，返回指定列数据的平均值 |

### MySQL 流程控制函数

| 函数名称 | 作用           |
| :------- | :------------- |
| if       | 判断，流程控制 |
| ifnull   | 判断是否为空   |
| case     | 搜索语句       |

#### if:判断

> IF(expr,v1,v2)
>
> 当 expr 为真是返回 v1 的值，否则返回 v2

```
mysql> select if(1<2,1,0) c1,if(1>5,'√','×') c2,if(strcmp('abc','ab'),'yes','no') c3;
+----+----+-----+
| c1 | c2 | c3  |
+----+----+-----+
|  1 | ×  | yes |
+----+----+-----+
1 row in set (0.00 sec)
```

#### ifnull:判断是否为空

> IFNULL(v1,v2)：v1为空返回v2，否则返回v1。

```
mysql> select ifnull(null,'路人甲Java'),ifnull('非空','为空');
+------------------------------+---------------------------+
| ifnull(null,'路人甲Java')    | ifnull('非空','为空')     |
+------------------------------+---------------------------+
| 路人甲Java                   | 非空                      |
+------------------------------+---------------------------+
1 row in set (0.00 sec)
```

#### case:搜索语句,类似于java中的if..else if..else

> 类似于java中的if..else if..else

**有2种写法**

**方式1：**

```
CASE  <表达式>
   WHEN <值1> THEN <操作>
   WHEN <值2> THEN <操作>
   ...
   ELSE <操作>
END CASE;
```

**方式2：**

```
CASE
    WHEN <条件1> THEN <命令>
    WHEN <条件2> THEN <命令>
    ...
    ELSE commands
END CASE;
```

示例：

准备数据：

```
CREATE TABLE t_stu (
  id   INT AUTO_INCREMENT  COMMENT '编号',
  name VARCHAR(10) COMMENT '姓名',
  sex  TINYINT COMMENT '性别,0:未知,1:男,2:女',
  PRIMARY KEY (id)
) COMMENT '学生表';

insert into t_stu (name,sex) VALUES 
  ('张学友',1),
  ('刘德华',1),
  ('郭富城',1),
  ('蔡依林',2),
  ('xxx',0);
mysql> select * from t_stu;
+----+-----------+------+
| id | name      | sex  |
+----+-----------+------+
|  1 | 张学友    |    1 |
|  2 | 刘德华    |    1 |
|  3 | 郭富城    |    1 |
|  4 | 蔡依林    |    2 |
|  5 | xxx       |    0 |
+----+-----------+------+
5 rows in set (0.00 sec)
```

需求：查询所有学生信息，输出：姓名，性别（男、女、未知），如下：

```
mysql> SELECT
      t.name 姓名,
      (CASE t.sex
       WHEN 1
         THEN '男'
       WHEN 2
         THEN '女'
       ELSE '未知' END) 性别
    FROM t_stu t;
+-----------+--------+
| 姓名      | 性别   |
+-----------+--------+
| 张学友    | 男     |
| 刘德华    | 男     |
| 郭富城    | 男     |
| 蔡依林    | 女     |
| xxx       | 未知   |
+-----------+--------+
5 rows in set (0.00 sec)

mysql> SELECT
    t.name          姓名,
    (CASE
    WHEN t.sex = 1
    THEN '男'
    WHEN t.sex = 2
    THEN '女'
    ELSE '未知' END) 性别
    FROM t_stu t;
+-----------+--------+
| 姓名      | 性别   |
+-----------+--------+
| 张学友    | 男     |
| 刘德华    | 男     |
| 郭富城    | 男     |
| 蔡依林    | 女     |
| xxx       | 未知   |
+-----------+--------+
5 rows in set (0.00 sec)
```

### 其他函数

| 函数名称 | 作用                |
| :------- | :------------------ |
| version  | 数据库版本号        |
| database | 当前的数据库        |
| user     | 当前连接用户        |
| password | 返回字符串密码形式  |
| md5      | 返回字符串的md5数据 |

```
mysql> SELECT version();
+------------+
| version()  |
+------------+
| 5.7.25-log |
+------------+
1 row in set (0.00 sec)

mysql> SELECT database();
+--------------+
| database()   |
+--------------+
| javacode2018 |
+--------------+
1 row in set (0.00 sec)

mysql> SELECT user();
+----------------+
| user()         |
+----------------+
| root@localhost |
+----------------+
1 row in set (0.00 sec)

mysql> SELECT  password('123456');
+-------------------------------------------+
| password('123456')                        |
+-------------------------------------------+
| *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |
+-------------------------------------------+
1 row in set, 1 warning (0.00 sec)

mysql> SELECT md5('123456');
+----------------------------------+
| md5('123456')                    |
+----------------------------------+
| e10adc3949ba59abbe56e057f20f883e |
+----------------------------------+
1 row in set (0.00 sec)
```

# 连接查询

**当我们查询的数据来源于多张表的时候，我们需要用到连接查询，连接查询使用率非常高，希望大家都务必掌握。**

### 本文内容

1. 笛卡尔积
2. 内连接
3. 外连接
4. 左连接
5. 右连接
6. 表连接的原理
7. 使用java实现连接查询，加深理解

### 准备数据

> 2张表：
>
> t_team：组表。
>
> t_employee：员工表，内部有个team_id引用组表的id。

```
drop table if exists t_team;
create table t_team(
  id int not null AUTO_INCREMENT PRIMARY KEY comment '组id',
  team_name varchar(32) not null default '' comment '名称'
) comment '组表';

drop table if exists t_employee;
create table t_employee(
  id int not null AUTO_INCREMENT PRIMARY KEY comment '部门id',
  emp_name varchar(32) not null default '' comment '员工名称',
  team_id int not null default 0 comment '员工所在组id'
) comment '员工表表';

insert into t_team values (1,'架构组'),(2,'测试组'),(3,'java组'),(4,'前端组');
insert into t_employee values (1,'路人甲Java',1),(2,'张三',2),(3,'李四',3),(4,'王五',0),(5,'赵六',0);
```

`t_team`表4条记录，如下：

```
mysql> select * from t_team;
+----+-----------+
| id | team_name |
+----+-----------+
|  1 | 架构组    |
|  2 | 测试组    |
|  3 | java组    |
|  4 | 前端组    |
+----+-----------+
4 rows in set (0.00 sec)
```

`t_employee`表5条记录，如下：

```
mysql> select * from t_employee;
+----+---------------+---------+
| id | emp_name      | team_id |
+----+---------------+---------+
|  1 | 路人甲Java    |       1 |
|  2 | 张三          |       2 |
|  3 | 李四          |       3 |
|  4 | 王五          |       0 |
|  5 | 赵六          |       0 |
+----+---------------+---------+
5 rows in set (0.00 sec)
```

### 笛卡尔积

介绍连接查询之前，我们需要先了解一下笛卡尔积。

笛卡尔积简单点理解：有两个集合A和B，笛卡尔积表示A集合中的元素和B集合中的元素任意相互关联产生的所有可能的结果。

假如A中有m个元素，B中有n个元素，A、B笛卡尔积产生的结果有m*n个结果，相当于循环遍历两个集合中的元素，任意组合。

java伪代码表示如下：

```
for(Object eleA : A){
    for(Object eleB : B){
        System.out.print(eleA+","+eleB);
    }
}
```

> 过程：拿A集合中的第1行，去匹配集合B中所有的行，然后再拿集合A中的第2行，去匹配集合B中所有的行，最后结果数量为m*n。

#### sql中笛卡尔积语法

```
select 字段 from 表1,表2[,表N];
或者
select 字段 from 表1 join 表2 [join 表N];
```

示例：

```
mysql> select * from t_team,t_employee;
+----+-----------+----+---------------+---------+
| id | team_name | id | emp_name      | team_id |
+----+-----------+----+---------------+---------+
|  1 | 架构组    |  1 | 路人甲Java    |       1 |
|  2 | 测试组    |  1 | 路人甲Java    |       1 |
|  3 | java组    |  1 | 路人甲Java    |       1 |
|  4 | 前端组    |  1 | 路人甲Java    |       1 |
|  1 | 架构组    |  2 | 张三          |       2 |
|  2 | 测试组    |  2 | 张三          |       2 |
|  3 | java组    |  2 | 张三          |       2 |
|  4 | 前端组    |  2 | 张三          |       2 |
|  1 | 架构组    |  3 | 李四          |       3 |
|  2 | 测试组    |  3 | 李四          |       3 |
|  3 | java组    |  3 | 李四          |       3 |
|  4 | 前端组    |  3 | 李四          |       3 |
|  1 | 架构组    |  4 | 王五          |       0 |
|  2 | 测试组    |  4 | 王五          |       0 |
|  3 | java组    |  4 | 王五          |       0 |
|  4 | 前端组    |  4 | 王五          |       0 |
|  1 | 架构组    |  5 | 赵六          |       0 |
|  2 | 测试组    |  5 | 赵六          |       0 |
|  3 | java组    |  5 | 赵六          |       0 |
|  4 | 前端组    |  5 | 赵六          |       0 |
+----+-----------+----+---------------+---------+
20 rows in set (0.00 sec)
```

t_team表4条记录，t_employee表5条记录，笛卡尔积结果输出了20行记录。

### 内连接

**语法：**

```
select 字段 from 表1 inner join 表2 on 连接条件;
或
select 字段 from 表1 join 表2 on 连接条件;
或
select 字段 from 表1, 表2 [where 关联条件];
```

> 内连接相当于在笛卡尔积的基础上加上了连接的条件。
>
> 当没有连接条件的时候，内连接上升为笛卡尔积。

过程用java伪代码如下：

```
for(Object eleA : A){
    for(Object eleB : B){
        if(连接条件是否为true){
            System.out.print(eleA+","+eleB);
        }
    }
}
```

#### 示例1：有连接条件

> 查询员工及所属部门

```
mysql> select t1.emp_name,t2.team_name from t_employee t1 inner join t_team t2 on t1.team_id = t2.id;
+---------------+-----------+
| emp_name      | team_name |
+---------------+-----------+
| 路人甲Java    | 架构组    |
| 张三          | 测试组    |
| 李四          | java组    |
+---------------+-----------+
3 rows in set (0.00 sec)

mysql> select t1.emp_name,t2.team_name from t_employee t1 join t_team t2 on t1.team_id = t2.id;
+---------------+-----------+
| emp_name      | team_name |
+---------------+-----------+
| 路人甲Java    | 架构组    |
| 张三          | 测试组    |
| 李四          | java组    |
+---------------+-----------+
3 rows in set (0.00 sec)

mysql> select t1.emp_name,t2.team_name from t_employee t1, t_team t2 where t1.team_id = t2.id;
+---------------+-----------+
| emp_name      | team_name |
+---------------+-----------+
| 路人甲Java    | 架构组    |
| 张三          | 测试组    |
| 李四          | java组    |
+---------------+-----------+
3 rows in set (0.00 sec)
```

> 上面相当于获取了2个表的交集，查询出了两个表都有的数据。

#### 示例2：无连接条件

> 无条件内连接，上升为笛卡尔积，如下：

```
mysql> select t1.emp_name,t2.team_name from t_employee t1 inner join t_team t2;
+---------------+-----------+
| emp_name      | team_name |
+---------------+-----------+
| 路人甲Java    | 架构组    |
| 路人甲Java    | 测试组    |
| 路人甲Java    | java组    |
| 路人甲Java    | 前端组    |
| 张三          | 架构组    |
| 张三          | 测试组    |
| 张三          | java组    |
| 张三          | 前端组    |
| 李四          | 架构组    |
| 李四          | 测试组    |
| 李四          | java组    |
| 李四          | 前端组    |
| 王五          | 架构组    |
| 王五          | 测试组    |
| 王五          | java组    |
| 王五          | 前端组    |
| 赵六          | 架构组    |
| 赵六          | 测试组    |
| 赵六          | java组    |
| 赵六          | 前端组    |
+---------------+-----------+
20 rows in set (0.00 sec)
```

#### 示例3：组合条件进行查询

> 查询架构组的员工，3种写法

```
mysql> select t1.emp_name,t2.team_name from t_employee t1 inner join t_team t2 on t1.team_id = t2.id and t2.team_name = '架构组';
+---------------+-----------+
| emp_name      | team_name |
+---------------+-----------+
| 路人甲Java    | 架构组    |
+---------------+-----------+
1 row in set (0.00 sec)

mysql> select t1.emp_name,t2.team_name from t_employee t1 inner join t_team t2 on t1.team_id = t2.id where t2.team_name = '架构组';
+---------------+-----------+
| emp_name      | team_name |
+---------------+-----------+
| 路人甲Java    | 架构组    |
+---------------+-----------+
1 row in set (0.00 sec)

mysql> select t1.emp_name,t2.team_name from t_employee t1, t_team t2 where t1.team_id = t2.id and t2.team_name = '架构组';
+---------------+-----------+
| emp_name      | team_name |
+---------------+-----------+
| 路人甲Java    | 架构组    |
+---------------+-----------+
1 row in set (0.00 sec)
```

上面3中方式解说。

方式1：on中使用了组合条件。

方式2：在连接的结果之后再进行过滤，相当于先获取连接的结果，然后使用where中的条件再对连接结果进行过滤。

方式3：直接在where后面进行过滤。

#### 总结

内连接建议使用第3种语法，简洁：

```
select 字段 from 表1, 表2 [where 关联条件];
```

### 外连接

外连接涉及到2个表，分为：主表和从表，要查询的信息主要来自于哪个表，谁就是主表。

外连接查询结果为主表中所有记录。如果从表中有和它匹配的，则显示匹配的值，这部分相当于内连接查询出来的结果；如果从表中没有和它匹配的，则显示null。

**最终：外连接查询结果 = 内连接的结果 + 主表中有的而内连接结果中没有的记录。**

**外连接分为2种：**

**左外链接：使用left join关键字，left join左边的是主表。**

**右外连接：使用right join关键字，right join右边的是主表。**

### 左连接

#### 语法

```
select 列 from 主表 left join 从表 on 连接条件;
```

#### 示例1:

查询所有员工信息，并显示员工所在组，如下：

```
mysql> SELECT
        t1.emp_name,
        t2.team_name
    FROM
        t_employee t1
    LEFT JOIN
        t_team t2
    ON
        t1.team_id = t2.id;
+---------------+-----------+
| emp_name      | team_name |
+---------------+-----------+
| 路人甲Java    | 架构组    |
| 张三          | 测试组    |
| 李四          | java组    |
| 王五          | NULL      |
| 赵六          | NULL      |
+---------------+-----------+
5 rows in set (0.00 sec)
```

上面查询出了所有员工，员工team_id=0的，team_name为NULL。

#### 示例2：

查询员工姓名、组名，返回组名不为空的记录，如下：

```
mysql> SELECT
        t1.emp_name,
        t2.team_name
    FROM
        t_employee t1
    LEFT JOIN
        t_team t2
    ON
        t1.team_id = t2.id
    WHERE
        t2.team_name IS NOT NULL;
+---------------+-----------+
| emp_name      | team_name |
+---------------+-----------+
| 路人甲Java    | 架构组    |
| 张三          | 测试组    |
| 李四          | java组    |
+---------------+-----------+
3 rows in set (0.00 sec)
```

上面先使用内连接获取连接结果，然后再使用where对连接结果进行过滤。

### 右连接

#### 语法

```
select 列 from 从表 right join 主表 on 连接条件;
```

#### 示例

我们使用右连接来实现上面左连接实现的功能，如下：

```
mysql> SELECT
        t2.team_name,
        t1.emp_name
    FROM
        t_team t2
    RIGHT JOIN
        t_employee t1
    ON
        t1.team_id = t2.id;
+-----------+---------------+
| team_name | emp_name      |
+-----------+---------------+
| 架构组    | 路人甲Java    |
| 测试组    | 张三          |
| java组    | 李四          |
| NULL      | 王五          |
| NULL      | 赵六          |
+-----------+---------------+
5 rows in set (0.00 sec)

mysql> SELECT
        t2.team_name,
        t1.emp_name
    FROM
        t_team t2
    RIGHT JOIN
        t_employee t1
    ON
        t1.team_id = t2.id
    WHERE
        t2.team_name IS NOT NULL;
+-----------+---------------+
| team_name | emp_name      |
+-----------+---------------+
| 架构组    | 路人甲Java    |
| 测试组    | 张三          |
| java组    | 李四          |
+-----------+---------------+
3 rows in set (0.00 sec)
```

### 理解表连接原理

**准备数据**

```
drop table if exists test1;
create table test1(
  a int
);
drop table if exists test2;
create table test2(
  b int
);
insert into test1 values (1),(2),(3);
insert into test2 values (3),(4),(5);
mysql> select * from test1;
+------+
| a    |
+------+
|    1 |
|    2 |
|    3 |
+------+
3 rows in set (0.00 sec)

mysql> select * from test2;
+------+
| b    |
+------+
|    3 |
|    4 |
|    5 |
+------+
3 rows in set (0.00 sec)
```

我们来写几个连接，看看效果。

#### 示例1：内连接

```
mysql> select * from test1 t1,test2 t2;
+------+------+
| a    | b    |
+------+------+
|    1 |    3 |
|    2 |    3 |
|    3 |    3 |
|    1 |    4 |
|    2 |    4 |
|    3 |    4 |
|    1 |    5 |
|    2 |    5 |
|    3 |    5 |
+------+------+
9 rows in set (0.00 sec)

mysql> select * from test1 t1,test2 t2 where t1.a = t2.b;
+------+------+
| a    | b    |
+------+------+
|    3 |    3 |
+------+------+
1 row in set (0.00 sec)
```

9条数据正常。

#### 示例2：左连接

```
mysql> select * from test1 t1 left join test2 t2 on t1.a = t2.b;
+------+------+
| a    | b    |
+------+------+
|    3 |    3 |
|    1 | NULL |
|    2 | NULL |
+------+------+
3 rows in set (0.00 sec)

mysql> select * from test1 t1 left join test2 t2 on t1.a>10;
+------+------+
| a    | b    |
+------+------+
|    1 | NULL |
|    2 | NULL |
|    3 | NULL |
+------+------+
3 rows in set (0.00 sec)

mysql> select * from test1 t1 left join test2 t2 on 1=1;
+------+------+
| a    | b    |
+------+------+
|    1 |    3 |
|    2 |    3 |
|    3 |    3 |
|    1 |    4 |
|    2 |    4 |
|    3 |    4 |
|    1 |    5 |
|    2 |    5 |
|    3 |    5 |
+------+------+
9 rows in set (0.00 sec)
```

上面的左连接第一个好理解。

第2个sql连接条件`t1.a>10`，这个条件只关联了test1表，再看看结果，是否可以理解？不理解的继续向下看，我们用java代码来实现连接查询。

第3个sql中的连接条件1=1值为true，返回结果为笛卡尔积。

### java代码实现连接查询

> 下面是一个简略版的实现

```
package com.itsoku.sql;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.stream.Collectors;

public class Test1 {
    public static class Table1 {
        int a;

        public int getA() {
            return a;
        }

        public void setA(int a) {
            this.a = a;
        }

        public Table1(int a) {
            this.a = a;
        }

        @Override
        public String toString() {
            return "Table1{" +
                    "a=" + a +
                    '}';
        }

        public static Table1 build(int a) {
            return new Table1(a);
        }
    }

    public static class Table2 {
        int b;

        public int getB() {
            return b;
        }

        public void setB(int b) {
            this.b = b;
        }

        public Table2(int b) {
            this.b = b;
        }

        public static Table2 build(int b) {
            return new Table2(b);
        }

        @Override
        public String toString() {
            return "Table2{" +
                    "b=" + b +
                    '}';
        }
    }

    public static class Record<R1, R2> {
        R1 r1;
        R2 r2;

        public R1 getR1() {
            return r1;
        }

        public void setR1(R1 r1) {
            this.r1 = r1;
        }

        public R2 getR2() {
            return r2;
        }

        public void setR2(R2 r2) {
            this.r2 = r2;
        }

        public Record(R1 r1, R2 r2) {
            this.r1 = r1;
            this.r2 = r2;
        }

        @Override
        public String toString() {
            return "Record{" +
                    "r1=" + r1 +
                    ", r2=" + r2 +
                    '}';
        }

        public static <R1, R2> Record<R1, R2> build(R1 r1, R2 r2) {
            return new Record(r1, r2);
        }
    }

    public static enum JoinType {
        innerJoin, leftJoin
    }


    public static interface Filter<R1, R2> {
        boolean accept(R1 r1, R2 r2);
    }

    public static <R1, R2> List<Record<R1, R2>> join(List<R1> table1, List<R2> table2, JoinType joinType, Filter<R1, R2> onFilter, Filter<R1, R2> whereFilter) {
        if (Objects.isNull(table1) || Objects.isNull(table2) || joinType == null) {
            return new ArrayList<>();
        }

        List<Record<R1, R2>> result = new CopyOnWriteArrayList<>();

        for (R1 r1 : table1) {
            List<Record<R1, R2>> onceJoinResult = joinOn(r1, table2, onFilter);
            result.addAll(onceJoinResult);
        }

        if (joinType == JoinType.leftJoin) {
            List<R1> r1Record = result.stream().map(Record::getR1).collect(Collectors.toList());
            List<Record<R1, R2>> leftAppendList = new ArrayList<>();
            for (R1 r1 : table1) {
                if (!r1Record.contains(r1)) {
                    leftAppendList.add(Record.build(r1, null));
                }
            }
            result.addAll(leftAppendList);
        }
        if (Objects.nonNull(whereFilter)) {
            for (Record<R1, R2> record : result) {
                if (!whereFilter.accept(record.r1, record.r2)) {
                    result.remove(record);
                }
            }
        }
        return result;
    }

    public static <R1, R2> List<Record<R1, R2>> joinOn(R1 r1, List<R2> table2, Filter<R1, R2> onFilter) {
        List<Record<R1, R2>> result = new ArrayList<>();
        for (R2 r2 : table2) {
            if (Objects.nonNull(onFilter) ? onFilter.accept(r1, r2) : true) {
                result.add(Record.build(r1, r2));
            }
        }
        return result;
    }

    @Test
    public void innerJoin() {
        List<Table1> table1 = Arrays.asList(Table1.build(1), Table1.build(2), Table1.build(3));
        List<Table2> table2 = Arrays.asList(Table2.build(3), Table2.build(4), Table2.build(5));

        join(table1, table2, JoinType.innerJoin, null, null).forEach(System.out::println);
        System.out.println("-----------------");
        join(table1, table2, JoinType.innerJoin, (r1, r2) -> r1.a == r2.b, null).forEach(System.out::println);
    }

    @Test
    public void leftJoin() {
        List<Table1> table1 = Arrays.asList(Table1.build(1), Table1.build(2), Table1.build(3));
        List<Table2> table2 = Arrays.asList(Table2.build(3), Table2.build(4), Table2.build(5));

        join(table1, table2, JoinType.leftJoin, (r1, r2) -> r1.a == r2.b, null).forEach(System.out::println);
        System.out.println("-----------------");
        join(table1, table2, JoinType.leftJoin, (r1, r2) -> r1.a > 10, null).forEach(System.out::println);
    }

}
```

**代码中的`innerJoin()`方法模拟了下面的sql：**

```
mysql> select * from test1 t1,test2 t2;
+------+------+
| a    | b    |
+------+------+
|    1 |    3 |
|    2 |    3 |
|    3 |    3 |
|    1 |    4 |
|    2 |    4 |
|    3 |    4 |
|    1 |    5 |
|    2 |    5 |
|    3 |    5 |
+------+------+
9 rows in set (0.00 sec)

mysql> select * from test1 t1,test2 t2 where t1.a = t2.b;
+------+------+
| a    | b    |
+------+------+
|    3 |    3 |
+------+------+
1 row in set (0.00 sec)
```

运行一下`innerJoin()`输出如下：

```
Record{r1=Table1{a=1}, r2=Table2{b=3}}
Record{r1=Table1{a=1}, r2=Table2{b=4}}
Record{r1=Table1{a=1}, r2=Table2{b=5}}
Record{r1=Table1{a=2}, r2=Table2{b=3}}
Record{r1=Table1{a=2}, r2=Table2{b=4}}
Record{r1=Table1{a=2}, r2=Table2{b=5}}
Record{r1=Table1{a=3}, r2=Table2{b=3}}
Record{r1=Table1{a=3}, r2=Table2{b=4}}
Record{r1=Table1{a=3}, r2=Table2{b=5}}
-----------------
Record{r1=Table1{a=3}, r2=Table2{b=3}}
```

对比一下sql和java的结果，输出的结果条数、数据基本上一致，唯一不同的是顺序上面不一样，**顺序为何不一致，稍微介绍**。

**代码中的`leftJoin()`方法模拟了下面的sql：**

```
mysql> select * from test1 t1 left join test2 t2 on t1.a = t2.b;
+------+------+
| a    | b    |
+------+------+
|    3 |    3 |
|    1 | NULL |
|    2 | NULL |
+------+------+
3 rows in set (0.00 sec)

mysql> select * from test1 t1 left join test2 t2 on t1.a>10;
+------+------+
| a    | b    |
+------+------+
|    1 | NULL |
|    2 | NULL |
|    3 | NULL |
+------+------+
3 rows in set (0.00 sec)
```

运行`leftJoin()`，结果如下：

```
Record{r1=Table1{a=3}, r2=Table2{b=3}}
Record{r1=Table1{a=1}, r2=null}
Record{r1=Table1{a=2}, r2=null}
-----------------
Record{r1=Table1{a=1}, r2=null}
Record{r1=Table1{a=2}, r2=null}
Record{r1=Table1{a=3}, r2=null}
```

效果和sql的效果完全一致，可以对上。

**现在我们来讨论java输出的顺序为何和sql不一致？**

> 上面java代码中两个表的连接查询使用了嵌套循环，外循环每执行一次，内循环的表都会全部遍历一次，如果放到mysql中，就相当于内标全部扫描了一次（一次全表io读取操作），主表（外循环）如果有n条数据，那么从表就需要全表扫描n次，表的数据是存储在磁盘中，每次全表扫描都需要做io操作，io操作是最耗时间的，如果mysql按照上面的java方式实现，那效率肯定很低。

**那mysql是如何优化的呢？**

> msql内部使用了一个内存缓存空间，就叫他`join_buffer`吧，先把外循环的数据放到`join_buffer`中，然后对从表进行遍历，从表中取一条数据和`join_buffer`的数据进行比较，然后从表中再取第2条和`join_buffer`数据进行比较，直到从表遍历完成，使用这方方式来减少从表的io扫描次数，当`join_buffer`足够大的时候，大到可以存放主表所有数据，那么从表只需要全表扫描一次（即只需要一次全表io读取操作）。
>
> mysql中这种方式叫做`Block Nested Loop`。

**java代码改进一下，来实现join_buffer的过程。**

### java代码改进版本

```
package com.itsoku.sql;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.stream.Collectors;

import com.itsoku.sql.Test1.*;

public class Test2 {

    public static int joinBufferSize = 10000;
    public static List<?> joinBufferList = new ArrayList<>();

    public static <R1, R2> List<Record<R1, R2>> join(List<R1> table1, List<R2> table2, JoinType joinType, Filter<R1, R2> onFilter, Filter<R1, R2> whereFilter) {
        if (Objects.isNull(table1) || Objects.isNull(table2) || joinType == null) {
            return new ArrayList<>();
        }

        List<Test1.Record<R1, R2>> result = new CopyOnWriteArrayList<>();

        int table1Size = table1.size();
        int fromIndex = 0, toIndex = joinBufferSize;
        toIndex = Integer.min(table1Size, toIndex);
        while (fromIndex < table1Size && toIndex <= table1Size) {
            joinBufferList = table1.subList(fromIndex, toIndex);
            fromIndex = toIndex;
            toIndex += joinBufferSize;
            toIndex = Integer.min(table1Size, toIndex);

            List<Record<R1, R2>> blockNestedLoopResult = blockNestedLoop((List<R1>) joinBufferList, table2, onFilter);
            result.addAll(blockNestedLoopResult);
        }

        if (joinType == JoinType.leftJoin) {
            List<R1> r1Record = result.stream().map(Record::getR1).collect(Collectors.toList());
            List<Record<R1, R2>> leftAppendList = new ArrayList<>();
            for (R1 r1 : table1) {
                if (!r1Record.contains(r1)) {
                    leftAppendList.add(Record.build(r1, null));
                }
            }
            result.addAll(leftAppendList);
        }
        if (Objects.nonNull(whereFilter)) {
            for (Record<R1, R2> record : result) {
                if (!whereFilter.accept(record.r1, record.r2)) {
                    result.remove(record);
                }
            }
        }
        return result;
    }

    public static <R1, R2> List<Record<R1, R2>> blockNestedLoop(List<R1> joinBufferList, List<R2> table2, Filter<R1, R2> onFilter) {
        List<Record<R1, R2>> result = new ArrayList<>();
        for (R2 r2 : table2) {
            for (R1 r1 : joinBufferList) {
                if (Objects.nonNull(onFilter) ? onFilter.accept(r1, r2) : true) {
                    result.add(Record.build(r1, r2));
                }
            }
        }
        return result;
    }

    @Test
    public void innerJoin() {
        List<Table1> table1 = Arrays.asList(Table1.build(1), Table1.build(2), Table1.build(3));
        List<Table2> table2 = Arrays.asList(Table2.build(3), Table2.build(4), Table2.build(5));

        join(table1, table2, JoinType.innerJoin, null, null).forEach(System.out::println);
        System.out.println("-----------------");
        join(table1, table2, JoinType.innerJoin, (r1, r2) -> r1.a == r2.b, null).forEach(System.out::println);
    }

    @Test
    public void leftJoin() {
        List<Table1> table1 = Arrays.asList(Table1.build(1), Table1.build(2), Table1.build(3));
        List<Table2> table2 = Arrays.asList(Table2.build(3), Table2.build(4), Table2.build(5));

        join(table1, table2, JoinType.leftJoin, (r1, r2) -> r1.a == r2.b, null).forEach(System.out::println);
        System.out.println("-----------------");
        join(table1, table2, JoinType.leftJoin, (r1, r2) -> r1.a > 10, null).forEach(System.out::println);
    }
}
```

执行`innerJoin()`，输出：

```
Record{r1=Table1{a=1}, r2=Table2{b=3}}
Record{r1=Table1{a=2}, r2=Table2{b=3}}
Record{r1=Table1{a=3}, r2=Table2{b=3}}
Record{r1=Table1{a=1}, r2=Table2{b=4}}
Record{r1=Table1{a=2}, r2=Table2{b=4}}
Record{r1=Table1{a=3}, r2=Table2{b=4}}
Record{r1=Table1{a=1}, r2=Table2{b=5}}
Record{r1=Table1{a=2}, r2=Table2{b=5}}
Record{r1=Table1{a=3}, r2=Table2{b=5}}
-----------------
Record{r1=Table1{a=3}, r2=Table2{b=3}}
```

执行`leftJoin()`，输出：

```
Record{r1=Table1{a=3}, r2=Table2{b=3}}
Record{r1=Table1{a=1}, r2=null}
Record{r1=Table1{a=2}, r2=null}
-----------------
Record{r1=Table1{a=1}, r2=null}
Record{r1=Table1{a=2}, r2=null}
Record{r1=Table1{a=3}, r2=null}
```

结果和sql的结果完全一致。

### 扩展

表连接中还可以使用前面学过的`group by`、`having`、`order by`、`limit`。

这些关键字相当于在表连接的结果上在进行操作，大家下去可以练习一下，加深理解。

# 子查询

### 子查询

出现在select语句中的select语句，称为子查询或内查询。

外部的select查询语句，称为主查询或外查询。

### 子查询分类

#### 按结果集的行列数不同分为4种

- 标量子查询（结果集只有一行一列）
- 列子查询（结果集只有一列多行）
- 行子查询（结果集有一行多列）
- 表子查询（结果集一般为多行多列）

#### 按子查询出现在主查询中的不同位置分

- **select后面**：仅仅支持标量子查询。
- **from后面**：支持表子查询。
- **where或having后面**：支持标量子查询（单列单行）、列子查询（单列多行）、行子查询（多列多行）
- **exists后面（即相关子查询）**：表子查询（多行、多列）

### 准备测试数据

测试数据比较多，放在我的个人博客上了。

浏览器中打开链接：http://www.itsoku.com/article/209

mysql中执行里面的`javacode2018_employees库`部分的脚本。

成功创建`javacode2018_employees`库及5张表，如下：

| 表名        | 描述                     |
| :---------- | :----------------------- |
| departments | 部门表                   |
| employees   | 员工信息表               |
| jobs        | 职位信息表               |
| locations   | 位置表（部门表中会用到） |
| job_grades  | 薪资等级表               |

### select后面的子查询

> 子查询位于select后面的，**仅仅支持标量子查询**。

#### 示例1

> 查询每个部门员工个数

```
SELECT
  a.*,
  (SELECT count(*)
   FROM employees b
   WHERE b.department_id = a.department_id) AS 员工个数
FROM departments a;
```

#### 示例2

> 查询员工号=102的部门名称

```
SELECT (SELECT a.department_name
        FROM departments a, employees b
        WHERE a.department_id = b.department_id
              AND b.employee_id = 102) AS 部门名;
```

### from后面的子查询

> 将子查询的结果集充当一张表，要求必须起别名，否者这个表找不到。
>
> 然后将真实的表和子查询结果表进行连接查询。

#### 示例1

> 查询每个部门平均工资的工资等级

```
-- 查询每个部门平均工资
SELECT
  department_id,
  avg(a.salary)
FROM employees a
GROUP BY a.department_id;

-- 薪资等级表
SELECT *
FROM job_grades;

-- 将上面2个结果连接查询，筛选条件:平均工资 between lowest_sal and highest_sal;
SELECT
  t1.department_id,
  sa AS '平均工资',
  t2.grade_level
FROM (SELECT
        department_id,
        avg(a.salary) sa
      FROM employees a
      GROUP BY a.department_id) t1, job_grades t2
WHERE
  t1.sa BETWEEN t2.lowest_sal AND t2.highest_sal;
```

运行最后一条结果如下：

```
mysql> SELECT
          t1.department_id,
          sa AS '平均工资',
          t2.grade_level
        FROM (SELECT
                department_id,
                avg(a.salary) sa
              FROM employees a
              GROUP BY a.department_id) t1, job_grades t2
        WHERE
          t1.sa BETWEEN t2.lowest_sal AND t2.highest_sal;
+---------------+--------------+-------------+
| department_id | 平均工资     | grade_level |
+---------------+--------------+-------------+
|          NULL |  7000.000000 | C           |
|            10 |  4400.000000 | B           |
|            20 |  9500.000000 | C           |
|            30 |  4150.000000 | B           |
|            40 |  6500.000000 | C           |
|            50 |  3475.555556 | B           |
|            60 |  5760.000000 | B           |
|            70 | 10000.000000 | D           |
|            80 |  8955.882353 | C           |
|            90 | 19333.333333 | E           |
|           100 |  8600.000000 | C           |
|           110 | 10150.000000 | D           |
+---------------+--------------+-------------+
12 rows in set (0.00 sec)
```

### where和having后面的子查询

#### where或having后面，可以使用

1. 标量子查询（单行单列行子查询）
2. 列子查询（单列多行子查询）
3. 行子查询（多行多列）

#### 特点

1. 子查询放在小括号内。
2. 子查询一般放在条件的右侧。
3. 标量子查询，一般搭配着单行操作符使用，多行操作符  **>、<、>=、<=、=、<>、!=**
4. 列子查询，一般搭配着多行操作符使用

> in(not in)：列表中的“任意一个”
>
> any或者some：和子查询返回的“某一个值”比较，比如a>som(10,20,30)，a大于子查询中任意一个即可，a大于子查询中最小值即可，等同于a>min(10,20,30)。
>
> all：和子查询返回的“所有值”比较，比如a>all(10,20,30)，a大于子查询中所有值，换句话说，a大于子查询中最大值即可满足查询条件，等同于a>max(10,20,30);

1. 子查询的执行优先于主查询执行，因为主查询的条件用到了子查询的结果。

#### mysql中的in、any、some、all

in，any，some，all分别是子查询关键词之一。

**in**：in常用于where表达式中，其作用是查询某个范围内的数据

**any和some一样**： 可以与=、>、>=、<、<=、<>结合起来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的任何一个数据。

**all**：可以与=、>、>=、<、<=、<>结合是来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的其中的所有数据。

下文中会经常用到这些关键字。

#### 标量子查询

##### 一般标量子查询，示例

> 查询谁的工资比Abel的高？

```
/*①查询abel的工资【改查询是标量子查询】*/
SELECT salary
FROM employees
WHERE last_name = 'Abel';

/*②查询员工信息，满足salary>①的结果*/
SELECT *
FROM employees a
WHERE a.salary > (SELECT salary
                  FROM employees
                  WHERE last_name = 'Abel');
```

##### 多个标量子查询，示例

> 返回job_id与141号员工相同，salary比143号员工多的员工、姓名、job_id和工资

```
/*返回job_id与141号员工相同，salary比143号员工多的员工、姓名、job_id和工资*/
/*①查询141号员工的job_id*/
SELECT job_id
FROM employees
WHERE employee_id = 141;
/*②查询143好员工的salary*/
SELECT salary
FROM employees
WHERE employee_id = 143;
/*③查询员工的姓名、job_id、工资，要求job_id=① and salary>②*/
SELECT
  a.last_name 姓名,
  a.job_id,
  a.salary    工资
FROM employees a
WHERE a.job_id = (SELECT job_id
                  FROM employees
                  WHERE employee_id = 141)
      AND
      a.salary > (SELECT salary
                  FROM employees
                  WHERE employee_id = 143);
```

##### 子查询+分组函数，示例

> 查询最低工资大于50号部门最低工资的部门id和其最低工资【having】

```
/*查询最低工资大于50号部门最低工资的部门id和其最低工资【having】*/
/*①查询50号部门的最低工资*/
SELECT min(salary)
FROM employees
WHERE department_id = 50;
/*②查询每个部门的最低工资*/
SELECT
  min(salary),
  department_id
FROM employees
GROUP BY department_id;
/*③在②的基础上筛选，满足min(salary)>①*/
SELECT
  min(a.salary) minsalary,
  department_id
FROM employees a
GROUP BY a.department_id
HAVING min(a.salary) > (SELECT min(salary)
                        FROM employees
                        WHERE department_id = 50);
```

##### 错误的标量子查询，示例

> 将上面的示例③中子查询语句中的min(salary)改为salary，执行效果如下：

```
mysql> SELECT
          min(a.salary) minsalary,
          department_id
        FROM employees a
        GROUP BY a.department_id
        HAVING min(a.salary) > (SELECT salary
                                FROM employees
                                WHERE department_id = 500000);
ERROR 1242 (21000): Subquery returns more than 1 row
```

> 错误提示：子查询返回的结果超过了1行记录。
>
> 说明：上面的子查询只支持**最多一列一行记录**。

#### 列子查询

> 列子查询需要搭配多行操作符使用：in(not in)、any/some、all。
>
> 为了提升效率，最好去重一下**distinct**关键字。

##### 示例1

> 返回location_id是1400或1700的部门中的所有员工姓名

```
/*返回location_id是1400或1700的部门中的所有员工姓名*/
/*方式1*/
/*①查询location_id是1400或1700的部门编号*/
SELECT DISTINCT department_id
FROM departments
WHERE location_id IN (1400, 1700);

/*②查询员工姓名，要求部门是①列表中的某一个*/
SELECT a.last_name
FROM employees a
WHERE a.department_id IN (SELECT DISTINCT department_id
                          FROM departments
                          WHERE location_id IN (1400, 1700));

/*方式2：使用any实现*/
SELECT a.last_name
FROM employees a
WHERE a.department_id = ANY (SELECT DISTINCT department_id
                             FROM departments
                             WHERE location_id IN (1400, 1700));

/*拓展，下面与not in等价*/
SELECT a.last_name
FROM employees a
WHERE a.department_id <> ALL (SELECT DISTINCT department_id
                             FROM departments
                             WHERE location_id IN (1400, 1700));
```

##### 示例2

> 返回其他工种中比job_id为'IT_PROG'工种任意工资低的员工的员工号、姓名、job_id、salary

```
/*返回其他工种中比job_id为'IT_PROG'工种任一工资低的员工的员工号、姓名、job_id、salary*/
/*①查询job_id为'IT_PROG'部门任-工资*/
SELECT DISTINCT salary
FROM employees
WHERE job_id = 'IT_PROG';

/*②查询员工号、姓名、job_id、salary，slary<①的任意一个*/
SELECT
  last_name,
  employee_id,
  job_id,
  salary
FROM employees
WHERE salary < ANY (SELECT DISTINCT salary
                    FROM employees
                    WHERE job_id = 'IT_PROG') AND job_id != 'IT_PROG';

/*或者*/
SELECT
  last_name,
  employee_id,
  job_id,
  salary
FROM employees
WHERE salary < (SELECT max(salary)
                FROM employees
                WHERE job_id = 'IT_PROG') AND job_id != 'IT_PROG';
```

##### 示例3

> 返回其他工种中比job_id为'IT_PROG'部门所有工资低的员工的员工号、姓名、job_id、salary

```
/*返回其他工种中比job_id为'IT_PROG'部门所有工资低的员工的员工号、姓名、job_id、salary*/
SELECT
  last_name,
  employee_id,
  job_id,
  salary
FROM employees
WHERE salary < ALL (SELECT DISTINCT salary
                    FROM employees
                    WHERE job_id = 'IT_PROG') AND job_id != 'IT_PROG';

/*或者*/
SELECT
  last_name,
  employee_id,
  job_id,
  salary
FROM employees
WHERE salary < (SELECT min(salary)
                FROM employees
                WHERE job_id = 'IT_PROG') AND job_id != 'IT_PROG';
```

#### 行子查询（结果集一行多列）

##### 示例

> 查询员工编号最小并且工资最高的员工信息，3种方式。

```
/*查询员工编号最小并且工资最高的员工信息*/
/*①查询最小的员工编号*/
SELECT min(employee_id)
FROM employees;
/*②查询最高工资*/
SELECT max(salary)
FROM employees;
/*③方式1：查询员工信息*/
SELECT *
FROM employees a
WHERE a.employee_id = (SELECT min(employee_id)
                       FROM employees)
      AND salary = (SELECT max(salary)
                    FROM employees);

/*方式2*/
SELECT *
FROM employees a
WHERE (a.employee_id, a.salary) = (SELECT
                                     min(employee_id),
                                     max(salary)
                                   FROM employees);
/*方式3*/
SELECT *
FROM employees a
WHERE (a.employee_id, a.salary) in (SELECT
                                     min(employee_id),
                                     max(salary)
                                   FROM employees);
```

> 方式1比较常见，方式2、3更简洁。

#### exists后面（也叫做相关子查询）

1. 语法：exists(玩转的查询语句)。
2. exists查询结果：1或0，exists查询的结果用来判断子查询的结果集中是否有值。
3. 一般来说，能用exists的子查询，绝对都能用in代替，所以exists用的少。
4. 和前面的查询不同，这先执行主查询，然后主查询查询的结果，在根据子查询进行过滤，子查询中涉及到主查询中用到的字段，所以叫相关子查询。

##### 示例1

> 简单示例

```
mysql> SELECT exists(SELECT employee_id
              FROM employees
              WHERE salary = 300000) AS 'exists返回1或者0';
+----------------------+
| exists返回1或者0     |
+----------------------+
|                    0 |
+----------------------+
1 row in set (0.00 sec)
```

##### 示例2

> 查询所有员工的部门名称

```
/*exists入门案例*/
SELECT exists(SELECT employee_id
              FROM employees
              WHERE salary = 300000) AS 'exists返回1或者0';

/*查询所有员工部门名*/
SELECT department_name
FROM departments a
WHERE exists(SELECT 1
             FROM employees b
             WHERE a.department_id = b.department_id);

/*使用in实现*/
SELECT department_name
FROM departments a
WHERE a.department_id IN (SELECT department_id
                          FROM employees);
```

##### 示例3

> 查询没有员工的部门

```
/*查询没有员工的部门*/
/*exists实现*/
SELECT *
FROM departments a
WHERE NOT exists(SELECT 1
                 FROM employees b
                 WHERE a.department_id = b.department_id AND b.department_id IS NOT NULL);
/*in的方式*/
SELECT *
FROM departments a
WHERE a.department_id NOT IN (SELECT department_id
                              FROM employees b
                              WHERE b.department_id IS NOT NULL);
```

> 上面脚本中有`b.department_id IS NOT NULL`，为什么，有大坑，向下看。

### NULL的大坑

#### 示例1

> 使用in的方式查询没有员工的部门，如下：

```
SELECT *
FROM departments a
WHERE a.department_id NOT IN (SELECT department_id
                              FROM employees b);
```

运行结果：

```
mysql> SELECT *
    -> FROM departments a
    -> WHERE a.department_id NOT IN (SELECT department_id
    ->                               FROM employees b);
Empty set (0.00 sec)
```

in的情况下，子查询中列的值为NULL的时候，外查询的结果为空。

**建议：建表是，列不允许为空。**

### 总结

1. 本文中讲解了常见的子查询，请大家务必多练习
2. 注意in、any、some、any的用法
3. 字段为空的时候，in查询有大坑，这个要注意
4. 建议创建表的时候，列不允许为空

# NULL导致的神坑

**当数据的值为NULL的时候，可能出现各种意想不到的效果，让人防不胜防，我们来看看NULL导致的各种神坑，如何避免？**

### 比较运算符中使用NULL

> 认真看下面的效果

```sql
mysql> select 1>NULL;
+--------+
| 1>NULL |
+--------+
|   NULL |
+--------+
1 row in set (0.00 sec)

mysql> select 1<NULL;
+--------+
| 1<NULL |
+--------+
|   NULL |
+--------+
1 row in set (0.00 sec)

mysql> select 1<>NULL;
+---------+
| 1<>NULL |
+---------+
|    NULL |
+---------+
1 row in set (0.00 sec)

mysql> select 1>NULL;
+--------+
| 1>NULL |
+--------+
|   NULL |
+--------+
1 row in set (0.00 sec)

mysql> select 1<NULL;
+--------+
| 1<NULL |
+--------+
|   NULL |
+--------+
1 row in set (0.00 sec)

mysql> select 1>=NULL;
+---------+
| 1>=NULL |
+---------+
|    NULL |
+---------+
1 row in set (0.00 sec)

mysql> select 1<=NULL;
+---------+
| 1<=NULL |
+---------+
|    NULL |
+---------+
1 row in set (0.00 sec)

mysql> select 1!=NULL;
+---------+
| 1!=NULL |
+---------+
|    NULL |
+---------+
1 row in set (0.00 sec)

mysql> select 1<>NULL;
+---------+
| 1<>NULL |
+---------+
|    NULL |
+---------+
1 row in set (0.00 sec)

mysql> select NULL=NULL,NULL!=NULL;
+-----------+------------+
| NULL=NULL | NULL!=NULL |
+-----------+------------+
|      NULL |       NULL |
+-----------+------------+
1 row in set (0.00 sec)

mysql> select 1 in (null),1 not in (null),null in (null),null not in (null);
+-------------+-----------------+----------------+--------------------+
| 1 in (null) | 1 not in (null) | null in (null) | null not in (null) |
+-------------+-----------------+----------------+--------------------+
|        NULL |            NULL |           NULL |               NULL |
+-------------+-----------------+----------------+--------------------+
1 row in set (0.00 sec)

mysql> select 1=any(select null),null=any(select null);
+--------------------+-----------------------+
| 1=any(select null) | null=any(select null) |
+--------------------+-----------------------+
|               NULL |                  NULL |
+--------------------+-----------------------+
1 row in set (0.00 sec)

mysql> select 1=all(select null),null=all(select null);
+--------------------+-----------------------+
| 1=all(select null) | null=all(select null) |
+--------------------+-----------------------+
|               NULL |                  NULL |
+--------------------+-----------------------+
1 row in set (0.00 sec)
```

**结论：任何值和NULL使用运算符（>、<、>=、<=、!=、<>）或者（in、not in、any/some、all）比较时，返回值都为NULL，NULL作为布尔值的时候，不为1也不为0。**

### 准备数据

```sql
mysql> create table test1(a int,b int);
Query OK, 0 rows affected (0.01 sec)

mysql> insert into test1 values (1,1),(1,null),(null,null);
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> select * from test1;
+------+------+
| a    | b    |
+------+------+
|    1 |    1 |
|    1 | NULL |
| NULL | NULL |
+------+------+
3 rows in set (0.00 sec)
```

上面3条数据，认真看一下，特别是注意上面NULL的记录。

### IN、NOT IN和NULL比较

#### IN和NULL比较

```sql
mysql> select * from test1;
+------+------+
| a    | b    |
+------+------+
|    1 |    1 |
|    1 | NULL |
| NULL | NULL |
+------+------+
3 rows in set (0.00 sec)

mysql> select * from test1 where a in (null);
Empty set (0.00 sec)

mysql> select * from test1 where a in (null,1);
+------+------+
| a    | b    |
+------+------+
|    1 |    1 |
|    1 | NULL |
+------+------+
2 rows in set (0.00 sec)
```

**结论：当IN和NULL比较时，无法查询出为NULL的记录。**

#### NOT IN 和NULL比较

```sql
mysql> select * from test1 where a not in (1);
Empty set (0.00 sec)

mysql> select * from test1 where a not in (null);
Empty set (0.00 sec)

mysql> select * from test1 where a not in (null,2);
Empty set (0.00 sec)

mysql> select * from test1 where a not in (2);
+------+------+
| a    | b    |
+------+------+
|    1 |    1 |
|    1 | NULL |
+------+------+
2 rows in set (0.00 sec)
```

**结论：当NOT IN 后面有NULL值时，不论什么情况下，整个sql的查询结果都为空。**

### EXISTS、NOT EXISTS和NULL比较

```sql
mysql> select * from test2;
+------+------+
| a    | b    |
+------+------+
|    1 |    1 |
|    1 | NULL |
| NULL | NULL |
+------+------+
3 rows in set (0.00 sec)

mysql> select * from test1 t1 where exists (select * from test2 t2 where t1.a = t2.a);
+------+------+
| a    | b    |
+------+------+
|    1 |    1 |
|    1 | NULL |
+------+------+
2 rows in set (0.00 sec)

mysql> select * from test1 t1 where not exists (select * from test2 t2 where t1.a = t2.a);
+------+------+
| a    | b    |
+------+------+
| NULL | NULL |
+------+------+
1 row in set (0.00 sec)
```

上面我们复制了表test1创建了表test2。

查询语句中使用exists、not exists对比test1.a=test2.a，**因为=不能比较NULL**，结果和预期一致。

### 判断NULL只能用IS NULL、IS NOT NULL

```sql
mysql> select 1 is not null;
+---------------+
| 1 is not null |
+---------------+
|             1 |
+---------------+
1 row in set (0.00 sec)

mysql> select 1 is null;
+-----------+
| 1 is null |
+-----------+
|         0 |
+-----------+
1 row in set (0.00 sec)

mysql> select null is null;
+--------------+
| null is null |
+--------------+
|            1 |
+--------------+
1 row in set (0.00 sec)

mysql> select null is not null;
+------------------+
| null is not null |
+------------------+
|                0 |
+------------------+
1 row in set (0.00 sec)
```

看上面的效果，返回的结果为1或者0。

**结论：判断是否为空只能用IS NULL、IS NOT NULL。**

### 聚合函数中NULL的坑

#### 示例

```sql
mysql> select count(a),count(b),count(*) from test1;
+----------+----------+----------+
| count(a) | count(b) | count(*) |
+----------+----------+----------+
|        2 |        1 |        3 |
+----------+----------+----------+
1 row in set (0.00 sec)
```

count(a)返回了2行记录，a字段为NULL的没有统计出来。

count(b)返回了1行记录，为NULL的2行记录没有统计出来。

count(*)可以统计所有数据，不论字段的数据是否为NULL。

#### 再继续看

```sql
mysql> select * from test1 where a is null;
+------+------+
| a    | b    |
+------+------+
| NULL | NULL |
+------+------+
1 row in set (0.00 sec)

mysql> select count(a) from test1 where a is null;
+----------+
| count(a) |
+----------+
|        0 |
+----------+
1 row in set (0.00 sec)
```

上面第1个sql使用is null查询出了结果，第2个sql中count(a)返回的是0行。

**结论：count(字段)无法统计字段为NULL的值，count(\*)可以统计值为null的行。**

### NULL不能作为主键的值

```sql
mysql> create table test3(a int primary key,b int);
Query OK, 0 rows affected (0.01 sec)

mysql> insert into test3 values (null,1);
ERROR 1048 (23000): Column 'a' cannot be null
```

上面我们创建了一个表`test3`，字段`a`未指定不能为空，插入了一条NULL的数据，报错原因：`a 字段的值不能为NULL`，我们看一下表的创建语句：

```sql
mysql> show create table test3;
+-------+------------+
| Table | Create Table      |
+-------+------------+
| test3 | CREATE TABLE `test3` (
  `a` int(11) NOT NULL,
  `b` int(11) DEFAULT NULL,
  PRIMARY KEY (`a`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
+-------+------------+
1 row in set (0.00 sec)
```

从上面的脚本可以看出，当字段为主键的时候，字段会自动设置为`not null`。

**结论：当字段为主键的时候，字段会自动设置为not null。**

**看了上面这些还是比较晕，NULL的情况确实比较难以处理，容易出错，最有效的方法就是避免使用NULL。所以，强烈建议创建字段的时候字段不允许为NULL，设置一个默认值。**

### 总结

- **NULL作为布尔值的时候，不为1也不为0**
- **任何值和NULL使用运算符（>、<、>=、<=、!=、<>）或者（in、not in、any/some、all），返回值都为NULL**
- **当IN和NULL比较时，无法查询出为NULL的记录**
- **当NOT IN 后面有NULL值时，不论什么情况下，整个sql的查询结果都为空**
- **判断是否为空只能用IS NULL、IS NOT NULL**
- **count(字段)无法统计字段为NULL的值，count(\*)可以统计值为null的行**
- **当字段为主键的时候，字段会自动设置为not null**
- **NULL导致的坑让人防不胜防，强烈建议创建字段的时候字段不允许为NULL，给个默认值**

# 事务

### 本篇内容

1. 什么是事务，它有什么用？
2. 事务的几个特性
3. 事务常见操作指令详解
4. 事务的隔离级别详解
5. 脏读、不可重复读、可重复读、幻读详解
6. 演示各种隔离级别产生的现象
7. 关于隔离级别的选择

### 什么是事务？

**数据库中的事务是指对数据库执行一批操作，这些操作最终要么全部执行成功，要么全部失败，不会存在部分成功的情况。**

**举个例子**

比如A用户给B用户转账100操作，过程如下：

```
1.从A账户扣100
2.给B账户加100
```

如果在事务的支持下，上面最终只有2种结果：

1. 操作成功：A账户减少100；B账户增加100
2. 操作失败：A、B两个账户都没有发生变化

如果没有事务的支持，可能出现错：A账户减少了100，此时系统挂了，导致B账户没有加上100，而A账户凭空少了100。

### 事务的几个特性(ACID)

#### 原子性(Atomicity)

事务的整个过程如原子操作一样，最终要么全部成功，或者全部失败，这个原子性是从最终结果来看的，从最终结果来看这个过程是不可分割的。

#### 一致性(Consistency)

事务开始之前、执行中、执行完毕，这些时间点，多个人去观察事务操作的数据的时候，看到的数据都是一致的，比如在事务操作过程中，A连接看到的是100，那么B此时也去看的时候也是100，不会说AB看到的数据不一样，他们在某个时间点看到的数据是一致的。

#### 隔离性(Isolation)

一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

#### 持久性(Durability)

一个事务一旦提交，他对数据库中数据的改变就应该是永久性的。当事务提交之后，数据会持久化到硬盘，修改是永久性的。

### Mysql中事务操作

mysql中事务默认是隐式事务，执行insert、update、delete操作的时候，数据库自动开启事务、提交或回滚事务。

是否开启隐式事务是由变量`autocommit`控制的。

所以事务分为**隐式事务**和**显式事务**。

#### 隐式事务

> 事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由mysql内部自动控制的。

查看变量`autocommit`是否开启了自动提交

```
mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set, 1 warning (0.00 sec)
```

> `autocommit`为ON表示开启了自动提交。

#### 显式事务

> 事务需要手动开启、提交或回滚，由开发者自己控制。

2种方式手动控制事务：

**方式1：**

语法：

```
//设置不自动提交事务
set autocommit=0;
//执行事务操作
commit|rollback;
```

示例1：提交事务操作，如下：

```
mysql> create table test1 (a int);
Query OK, 0 rows affected (0.01 sec)

mysql> select * from test1;
Empty set (0.00 sec)

mysql> set autocommit=0;
Query OK, 0 rows affected (0.00 sec)

mysql> insert into test1 values(1);
Query OK, 1 row affected (0.00 sec)

mysql> commit;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from test1;
+------+
| a    |
+------+
|    1 |
+------+
1 row in set (0.00 sec)
```

示例2：回滚事务操作，如下：

```
mysql> set autocommit=0;
Query OK, 0 rows affected (0.00 sec)

mysql> insert into test1 values(2);
Query OK, 1 row affected (0.00 sec)

mysql> rollback;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from test1;
+------+
| a    |
+------+
|    1 |
+------+
1 row in set (0.00 sec)
```

> 可以看到上面数据回滚了。

我们把`autocommit`还原回去：

```
mysql> set autocommit=1;
Query OK, 0 rows affected (0.00 sec)
```

**方式2：**

语法：

```
start transaction;//开启事务
//执行事务操作
commit|rollback;
```

示例1：提交事务操作，如下：

```
mysql> select * from test1;
+------+
| a    |
+------+
|    1 |
+------+
1 row in set (0.00 sec)

mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql> insert into test1 values (2);
Query OK, 1 row affected (0.00 sec)

mysql> insert into test1 values (3);
Query OK, 1 row affected (0.00 sec)

mysql> commit;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from test1;
+------+
| a    |
+------+
|    1 |
|    2 |
|    3 |
+------+
3 rows in set (0.00 sec)
```

> 上面成功插入了2条数据。

示例2：回滚事务操作，如下：

```
mysql> select * from test1;
+------+
| a    |
+------+
|    1 |
|    2 |
|    3 |
+------+
3 rows in set (0.00 sec)

mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql> delete from test1;
Query OK, 3 rows affected (0.00 sec)

mysql> rollback;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from test1;
+------+
| a    |
+------+
|    1 |
|    2 |
|    3 |
+------+
3 rows in set (0.00 sec)
```

> 上面事务中我们删除了`test1`的数据，显示删除了3行，最后回滚了事务。

#### savepoint关键字

在事务中我们执行了一大批操作，可能我们只想回滚部分数据，怎么做呢？

我们可以将一大批操作分为几个部分，然后指定回滚某个部分。可以使用`savepoin`来实现，效果如下：

先清除`test1`表数据：

```
mysql> delete from test1;
Query OK, 3 rows affected (0.00 sec)

mysql> select * from test1;
Empty set (0.00 sec)
```

演示`savepoint`效果，认真看：

```
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql> insert into test1 values (1);
Query OK, 1 row affected (0.00 sec)

mysql> savepoint part1;//设置一个保存点
Query OK, 0 rows affected (0.00 sec)

mysql> insert into test1 values (2);
Query OK, 1 row affected (0.00 sec)

mysql> rollback to part1;//将savepint = part1的语句到当前语句之间所有的操作回滚
Query OK, 0 rows affected (0.00 sec)

mysql> commit;//提交事务
Query OK, 0 rows affected (0.00 sec)

mysql> select * from test1;
+------+
| a    |
+------+
|    1 |
+------+
1 row in set (0.00 sec)
```

> 从上面可以看出，执行了2次插入操作，最后只插入了1条数据。
>
> `savepoint`需要结合`rollback to sp1`一起使用，可以将保存点`sp1`到`rollback to`之间的操作回滚掉。

#### 只读事务

表示在事务中执行的是一些只读操作，如查询，但是不会做insert、update、delete操作，数据库内部对只读事务可能会有一些性能上的优化。

用法如下：

```
start transaction read only;
```

示例：

```
mysql> commit;
Query OK, 0 rows affected (0.00 sec)

mysql> start transaction read only;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from test1;
+------+
| a    |
+------+
|    1 |
|    1 |
+------+
2 rows in set (0.00 sec)

mysql> delete from test1;
ERROR 1792 (25006): Cannot execute statement in a READ ONLY transaction.
mysql> commit;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from test1;
+------+
| a    |
+------+
|    1 |
|    1 |
+------+
2 rows in set (0.00 sec)
```

> 只读事务中执行delete会报错。

### 事务中的一些问题

这些问题主要是基于数据在多个事务中的可见性来说的。

#### 脏读

一个事务在执行的过程中读取到了其他事务还没有提交的数据。
这个还是比较好理解的。

#### 读已提交

从字面上我们就可以理解，即一个事务操作过程中可以读取到其他事务已经提交的数据。

事务中的每次读取操作，读取到的都是数据库中其他事务已提交的最新的数据（相当于当前读）

#### 可重复读

一个事务操作中对于一个读取操作不管多少次，读取到的结果都是一样的。

#### 幻读

脏读、不可重复读、可重复读、幻读，其中最难理解的是幻读

以mysql为例：

**幻读在可重复读的模式下才会出现，其他隔离级别中不会出现**

幻读现象例子：

可重复读模式下，比如有个用户表，手机号码为主键，有两个事物进行如下操作

事务A操作如下：
1、打开事务
2、查询号码为X的记录，不存在
3、插入号码为X的数据，插入报错（为什么会报错，先向下看）
4、查询号码为X的记录，发现还是不存在（由于是可重复读，所以读取记录X还是不存在的）

事物B操作：在事务A第2步操作时插入了一条X的记录，所以会导致A中第3步插入报错（违反了唯一约束）

上面操作对A来说就像发生了幻觉一样，明明查询X（A中第二步、第四步）不存在，但却无法插入成功

**幻读可以这么理解：事务中后面的操作（插入号码X）需要上面的读取操作（查询号码X的记录）提供支持，但读取操作却不能支持下面的操作时产生的错误，就像发生了幻觉一样。**

如果还是理解不了的，继续向下看，后面后详细的演示。

### 事务的隔离级别

当多个事务同时进行的时候，如何确保当前事务中数据的正确性，比如A、B两个事物同时进行的时候，A是否可以看到B已提交的数据或者B未提交的数据，这个需要依靠事务的隔离级别来保证，不同的隔离级别中所产生的效果是不一样的。

事务隔离级别主要是解决了上面多个事务之间数据可见性及数据正确性的问题。

**隔离级别分为4种：**

1. **读未提交：READ-UNCOMMITTED**
2. **读已提交：READ-COMMITTED**
3. **可重复读：REPEATABLE-READ**
4. **串行：SERIALIZABLE**

上面4中隔离级别越来越强，会导致数据库的并发性也越来越低。

#### 查看隔离级别

```
mysql> show variables like 'transaction_isolation';
+-----------------------+----------------+
| Variable_name         | Value          |
+-----------------------+----------------+
| transaction_isolation | READ-COMMITTED |
+-----------------------+----------------+
1 row in set, 1 warning (0.00 sec)
```

#### 隔离级别的设置

分2步骤，修改文件、重启mysql，如下：

修改mysql中的my.init文件，我们将隔离级别设置为：READ-UNCOMMITTED，如下：

```
# 隔离级别设置,READ-UNCOMMITTED读未提交,READ-COMMITTED读已提交,REPEATABLE-READ可重复读,SERIALIZABLE串行
transaction-isolation=READ-UNCOMMITTED
```

以管理员身份打开cmd窗口，重启mysql，如下：

```
C:\Windows\system32>net stop mysql
mysql 服务正在停止..
mysql 服务已成功停止。

C:\Windows\system32>net start mysql
mysql 服务正在启动 .
mysql 服务已经启动成功。
```

#### 各种隔离级别中会出现的问题

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| :--------------- | :--- | :--------- | :--- |
| READ-UNCOMMITTED | 有   | 有         | 无   |
| READ-COMMITTED   | 无   | 有         | 无   |
| REPEATABLE-READ  | 无   | 无         | 有   |
| SERIALIZABLE     | 无   | 无         | 无   |

> 表格中和网上有些不一样，主要是幻读这块，幻读只会在可重复读级别中才会出现，其他级别下不存在。

下面我们来演示一下，各种隔离级别中可见性的问题，开启两个窗口，叫做A、B窗口，两个窗口中登录mysql。

#### READ-UNCOMMITTED：读未提交

将隔离级别置为`READ-UNCOMMITTED`：

```
# 隔离级别设置,READ-UNCOMMITTED读未提交,READ-COMMITTED读已提交,REPEATABLE-READ可重复读,SERIALIZABLE串行
transaction-isolation=READ-UNCOMMITTED
```

重启mysql：

```
C:\Windows\system32>net stop mysql
mysql 服务正在停止..
mysql 服务已成功停止。

C:\Windows\system32>net start mysql
mysql 服务正在启动 .
mysql 服务已经启动成功。
```

查看隔离级别：

```
mysql> show variables like 'transaction_isolation';
+-----------------------+----------------+
| Variable_name         | Value          |
+-----------------------+----------------+
| transaction_isolation | READ-UNCOMMITTED |
+-----------------------+----------------+
1 row in set, 1 warning (0.00 sec)
```

先清空test1表数据：

```
delete from test1;
select * from test1;
```

按时间顺序在2个窗口中执行下面操作：

| 时间 | 窗口A                | 窗口B                         |
| :--- | :------------------- | :---------------------------- |
| T1   | start transaction;   |                               |
| T2   | select * from test1; |                               |
| T3   |                      | start transaction;            |
| T4   |                      | insert into test1 values (1); |
| T5   |                      | select * from test1;          |
| T6   | select * from test1; |                               |
| T7   |                      | commit;                       |
| T8   | commit;              |                               |

A窗口如下：

```
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from test1;
Empty set (0.00 sec)

mysql> select * from test1;
+------+
| a    |
+------+
|    1 |
+------+
1 row in set (0.00 sec)

mysql> commit;
Query OK, 0 rows affected (0.00 sec)
```

B窗口如下：

```
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql> insert into test1 values (1);
Query OK, 1 row affected (0.00 sec)

mysql> select * from test1;
+------+
| a    |
+------+
|    1 |
+------+
1 row in set (0.00 sec)

mysql> commit;
Query OK, 0 rows affected (0.00 sec)
```

看一下:

T2-A：无数据，T6-A：有数据，T6时刻B还未提交，此时A已经看到了B插入的数据，**说明出现了脏读**。

T2-A：无数据，T6-A：有数据，查询到的结果不一样，**说明不可重复读**。

**结论：读未提交情况下，可以读取到其他事务还未提交的数据，多次读取结果不一样，出现了脏读、不可重复读**

#### READ-COMMITTED：读已提交

将隔离级别置为`READ-COMMITTED`

```
# 隔离级别设置,READ-UNCOMMITTED读未提交,READ-COMMITTED读已提交,REPEATABLE-READ可重复读,SERIALIZABLE串行
transaction-isolation=READ-COMMITTED
```

重启mysql：

```
C:\Windows\system32>net stop mysql
mysql 服务正在停止..
mysql 服务已成功停止。

C:\Windows\system32>net start mysql
mysql 服务正在启动 .
mysql 服务已经启动成功。
```

查看隔离级别：

```
mysql> show variables like 'transaction_isolation';
+-----------------------+----------------+
| Variable_name         | Value          |
+-----------------------+----------------+
| transaction_isolation | READ-COMMITTED |
+-----------------------+----------------+
1 row in set, 1 warning (0.00 sec)
```

先清空test1表数据：

```
delete from test1;
select * from test1;
```

按时间顺序在2个窗口中执行下面操作：

| 时间 | 窗口A                | 窗口B                         |
| :--- | :------------------- | :---------------------------- |
| T1   | start transaction;   |                               |
| T2   | select * from test1; |                               |
| T3   |                      | start transaction;            |
| T4   |                      | insert into test1 values (1); |
| T5   |                      | select * from test1;          |
| T6   | select * from test1; |                               |
| T7   |                      | commit;                       |
| T8   | select * from test1; |                               |
| T9   | commit;              |                               |

A窗口如下：

```
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from test1;
Empty set (0.00 sec)

mysql> select * from test1;
Empty set (0.00 sec)

mysql> select * from test1;
+------+
| a    |
+------+
|    1 |
+------+
1 row in set (0.00 sec)

mysql> commit;
Query OK, 0 rows affected (0.00 sec)
```

B窗口如下：

```
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql> insert into test1 values (1);
Query OK, 1 row affected (0.00 sec)

mysql> select * from test1;
+------+
| a    |
+------+
|    1 |
+------+
1 row in set (0.00 sec)

mysql> commit;
Query OK, 0 rows affected (0.00 sec)
```

看一下:

T5-B：有数据，T6-A窗口：无数据，A看不到B的数据，**说明没有脏读**。

T6-A窗口：无数据，T8-A：看到了B插入的数据，此时B已经提交了，A看到了B已提交的数据，**说明可以读取到已提交的数据**。

T2-A、T6-A：无数据，T8-A：有数据，多次读取结果不一样，**说明不可重复读**。

**结论：读已提交情况下，无法读取到其他事务还未提交的数据，可以读取到其他事务已经提交的数据，多次读取结果不一样，未出现脏读，出现了读已提交、不可重复读。**

#### REPEATABLE-READ：可重复读

将隔离级别置为`REPEATABLE-READ`

```
# 隔离级别设置,READ-UNCOMMITTED读未提交,READ-COMMITTED读已提交,REPEATABLE-READ可重复读,SERIALIZABLE串行
transaction-isolation=REPEATABLE-READ
```

重启mysql：

```
C:\Windows\system32>net stop mysql
mysql 服务正在停止..
mysql 服务已成功停止。

C:\Windows\system32>net start mysql
mysql 服务正在启动 .
mysql 服务已经启动成功。
```

查看隔离级别：

```
mysql> show variables like 'transaction_isolation';
+-----------------------+----------------+
| Variable_name         | Value          |
+-----------------------+----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+----------------+
1 row in set, 1 warning (0.00 sec)
```

先清空test1表数据：

```
delete from test1;
select * from test1;
```

按时间顺序在2个窗口中执行下面操作：

| 时间 | 窗口A                | 窗口B                         |
| :--- | :------------------- | :---------------------------- |
| T1   | start transaction;   |                               |
| T2   | select * from test1; |                               |
| T3   |                      | start transaction;            |
| T4   |                      | insert into test1 values (1); |
| T5   |                      | select * from test1;          |
| T6   | select * from test1; |                               |
| T7   |                      | commit;                       |
| T8   | select * from test1; |                               |
| T9   | commit;              |                               |
| T10  | select * from test1; |                               |

A窗口如下：

```
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from test1;
Empty set (0.00 sec)

mysql> select * from test1;
Empty set (0.00 sec)

mysql> select * from test1;
Empty set (0.00 sec)

mysql> commit;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from test1;
+------+
| a    |
+------+
|    1 |
|    1 |
+------+
2 rows in set (0.00 sec)
```

B窗口如下：

```
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql> insert into test1 values (1);
Query OK, 1 row affected (0.00 sec)

mysql> select * from test1;
+------+
| a    |
+------+
|    1 |
|    1 |
+------+
2 rows in set (0.00 sec)

mysql> commit;
Query OK, 0 rows affected (0.00 sec)
```

看一下:

T2-A、T6-A窗口：无数据，T5-B：有数据，A看不到B的数据，**说明没有脏读**。

T8-A：无数据，此时B已经提交了，A看不到B已提交的数据，A中3次读的结果一样都是没有数据的，**说明可重复读**。

**结论：可重复读情况下，未出现脏读，未读取到其他事务已提交的数据，多次读取结果一致，即可重复读。**

#### 幻读演示

幻读只会在`REPEATABLE-READ`（可重复读）级别下出现，需要先把隔离级别改为可重复读。

将隔离级别置为`REPEATABLE-READ`

```
# 隔离级别设置,READ-UNCOMMITTED读未提交,READ-COMMITTED读已提交,REPEATABLE-READ可重复读,SERIALIZABLE串行
transaction-isolation=REPEATABLE-READ
```

重启mysql：

```
C:\Windows\system32>net stop mysql
mysql 服务正在停止..
mysql 服务已成功停止。

C:\Windows\system32>net start mysql
mysql 服务正在启动 .
mysql 服务已经启动成功。
```

查看隔离级别：

```
mysql> show variables like 'transaction_isolation';
+-----------------------+----------------+
| Variable_name         | Value          |
+-----------------------+----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+----------------+
1 row in set, 1 warning (0.00 sec)
```

准备数据：

```
mysql> create table t_user(id int primary key,name varchar(16) unique key);
Query OK, 0 rows affected (0.01 sec)

mysql> insert into t_user values (1,'路人甲Java'),(2,'路人甲Java');
ERROR 1062 (23000): Duplicate entry '路人甲Java' for key 'name'

mysql> select * from t_user;
Empty set (0.00 sec)
```

> 上面我们创建t_user表，name添加了唯一约束，表示name不能重复，否则报错。

按时间顺序在2个窗口中执行下面操作：

| 时间 | 窗口A                                                        | 窗口B                                                        |
| :--- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| T1   | start transaction;                                           |                                                              |
| T2   |                                                              | start transaction;                                           |
| T3   |                                                              | -- 插入`路人甲Java` insert into t_user values (1,'路人甲Java'); |
| T4   |                                                              | select * from t_user;                                        |
| T5   | -- 查看`路人甲Java`是否存在 select * from t_user where name='路人甲Java'; |                                                              |
| T6   |                                                              | commit;                                                      |
| T7   | -- 插入`路人甲Java` insert into t_user values (2,'路人甲Java'); |                                                              |
| T8   | -- 查看`路人甲Java`是否存在 select * from t_user where name='路人甲Java'; |                                                              |
| T9   | commit;                                                      |                                                              |

A窗口如下：

```
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from t_user where name='路人甲Java';
Empty set (0.00 sec)

mysql> insert into t_user values (2,'路人甲Java');
ERROR 1062 (23000): Duplicate entry '路人甲Java' for key 'name'
mysql> select * from t_user where name='路人甲Java';
Empty set (0.00 sec)

mysql> commit;
Query OK, 0 rows affected (0.00 sec)
```

B窗口如下：

```
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql> insert into t_user values (1,'路人甲Java');
Query OK, 1 row affected (0.00 sec)

mysql> select * from t_user;
+----+---------------+
| id | name          |
+----+---------------+
|  1 | 路人甲Java    |
+----+---------------+
1 row in set (0.00 sec)

mysql> commit;
Query OK, 0 rows affected (0.00 sec)
```

看一下:

A想插入数据`路人甲Java`，插入之前先查询了一下（T5时刻）该用户是否存在，发现不存在，然后在T7时刻执行插入，报错了，报数据已经存在了，因为T6时刻`B`已经插入了`路人甲Java`。

然后A有点郁闷，刚才查的时候不存在的，然后A不相信自己的眼睛，又去查一次（T8时刻），发现`路人甲Java`还是不存在的。

此时A心里想：数据明明不存在啊，为什么无法插入呢？这不是懵逼了么，A觉得如同发生了幻觉一样。

#### SERIALIZABLE：串行

**SERIALIZABLE会让并发的事务串行执行。**

看效果：

将隔离级别置为`SERIALIZABLE`

```
# 隔离级别设置,READ-UNCOMMITTED读未提交,READ-COMMITTED读已提交,REPEATABLE-READ可重复读,SERIALIZABLE串行
transaction-isolation=SERIALIZABLE
```

重启mysql：

```
C:\Windows\system32>net stop mysql
mysql 服务正在停止..
mysql 服务已成功停止。

C:\Windows\system32>net start mysql
mysql 服务正在启动 .
mysql 服务已经启动成功。
```

查看隔离级别：

```
mysql> show variables like 'transaction_isolation';
+-----------------------+--------------+
| Variable_name         | Value        |
+-----------------------+--------------+
| transaction_isolation | SERIALIZABLE |
+-----------------------+--------------+
1 row in set, 1 warning (0.00 sec)
```

先清空test1表数据：

```
delete from test1;
select * from test1;
```

按时间顺序在2个窗口中执行下面操作：

| 时间 | 窗口A                | 窗口B                         |
| :--- | :------------------- | :---------------------------- |
| T1   | start transaction;   |                               |
| T2   | select * from test1; |                               |
| T3   |                      | start transaction;            |
| T4   |                      | insert into test1 values (1); |
| T5   | select * from test1; |                               |
| T6   | commit;              |                               |
| T7   |                      | commit;                       |

按时间顺序运行上面的命令，会发现T4-B这样会被阻塞，直到T6-A执行完毕。

**可以看出来，事务只能串行执行了。串行情况下不存在脏读、不可重复读、幻读的问题了。**

### 关于隔离级别的选择

1. 需要对各种隔离级别产生的现象非常了解，然后选择的时候才能游刃有余
2. 隔离级别越高，并发性也低，比如最高级别`SERIALIZABLE`会让事物串行执行，并发操作变成串行了，会导致系统性能直接降低。
3. 具体选择哪种需要结合具体的业务来选择。
4. 读已提交（READ-COMMITTED）通常用的比较多。

### 总结

1. 理解事务的4个特性：原子性、一致性、隔离性、持久性
2. 掌握事务操作常见命令的介绍
3. `set autocommit`可以设置是否开启自动提交事务
4. start transaction：开启事务
5. start transaction read only：开启只读事物
6. commit：提交事务
7. rollback：回滚事务
8. savepoint：设置保存点
9. rollback to 保存点：可以回滚到某个保存点
10. 掌握4种隔离级别及了解其特点
11. 了解脏读、不可重复读、幻读

# 视图

https://www.cnblogs.com/geaozhang/p/6792369.html

### 需求背景

电商公司领导说：给我统计一下：当月订单总金额、订单量、男女订单占比等信息，我们啪啦啪啦写了一堆很复杂的sql，然后发给领导。

这样一大片sql，发给领导，你们觉得好么？

如果领导只想看其中某个数据，还需要修改你发来的sql，领导日后想新增其他的统计指标，你又会发送一大坨sql给领导，对于领导来说这个sql看起来很复杂，难以维护。

实际上领导并不关心你是怎么实现的，他关心的只是这些指标，并且方便查看、查询，而你却把复杂的实现都发给了领导。

那我们有什么办法隐藏这些细节，只暴露简洁的结果呢？

数据库已经帮我们想到了：使用视图来解决这个问题。

### 什么是视图

#### 概念

视图是在mysql5之后出现的，是一种虚拟表，行和列的数据来自于定义视图时使用的一些表中，**视图的数据是在使用视图的时候动态生成的，视图只保存了sql的逻辑，不保存查询的结果**。

#### 使用场景

多个地方使用到同样的查询结果，并且该查询结果比较复杂的时候，我们可以使用视图来隐藏复杂的实现细节。

#### 视图和表的区别

|      | 语法         | 实际中是否占用物理空间 | 使用                           |
| :--- | :----------- | :--------------------- | :----------------------------- |
| 视图 | create view  | 只是保存了sql的逻辑    | 增删改查，实际上我们只使用查询 |
| 表   | create table | 保存了数据             | 增删改查                       |

#### 视图的好处

- 简化复杂的sql操作，不用知道他的实现细节
- 隔离了原始表，可以不让使用视图的人接触原始的表，从而保护原始数据，提高了安全性

### 准备测试数据

测试数据比较多，放在我的个人博客上了。

浏览器中打开链接：http://www.itsoku.com/article/209

mysql中执行里面的`javacode2018_employees库`部分的脚本。

成功创建`javacode2018_employees`库及5张表，如下：

| 表名        | 描述                     |
| :---------- | :----------------------- |
| departments | 部门表                   |
| employees   | 员工信息表               |
| jobs        | 职位信息表               |
| locations   | 位置表（部门表中会用到） |
| job_grades  | 薪资等级表               |

### 创建视图

#### 语法

```
create view 视图名
as
查询语句;
```

#### 视图的使用步骤

- 创建视图
- 对视图执行查询操作

#### 案例1

> 查询姓名中包含a字符的员工名、部门、工种信息

```
/*案例1：查询姓名中包含a字符的员工名、部门、工种信息*/
/*①创建视图myv1*/
CREATE VIEW myv1
AS
  SELECT
    t1.last_name,
    t2.department_name,
    t3.job_title
  FROM employees t1, departments t2, jobs t3
  WHERE t1.department_id = t2.department_id
        AND t1.job_id = t3.job_id;

/*②使用视图*/
SELECT * FROM myv1 a where a.last_name like 'a%';
```

效果如下：

```
mysql> SELECT * FROM myv1 a where a.last_name like 'a%';
+-----------+-----------------+----------------------+
| last_name | department_name | job_title            |
+-----------+-----------------+----------------------+
| Austin    | IT              | Programmer           |
| Atkinson  | Shi             | Stock Clerk          |
| Ande      | Sal             | Sales Representative |
| Abel      | Sal             | Sales Representative |
+-----------+-----------------+----------------------+
4 rows in set (0.00 sec)
```

上面我们创建了一个视图：`myv1`，我们需要看`员工姓名、部门、工种`信息的时候，不用关心这个视图内部是什么样的，只需要查询视图就可以了，sql简单多了。

#### 案例2

> 案例2：查询各部门的平均工资级别

```
/*案例2：查询各部门的平均工资级别*/
/*①创建视图myv1*/
CREATE VIEW myv2
AS
  SELECT
    t1.department_id 部门id,
    t1.ag            平均工资,
    t2.grade_level   工资级别
  FROM (SELECT
          department_id,
          AVG(salary) ag
        FROM employees
        GROUP BY department_id)
       t1, job_grades t2
  WHERE t1.ag BETWEEN t2.lowest_sal AND t2.highest_sal;

/*②使用视图*/
SELECT * FROM myv2;
```

效果：

```
mysql> SELECT * FROM myv2;
+----------+--------------+--------------+
| 部门id   | 平均工资     | 工资级别     |
+----------+--------------+--------------+
|     NULL |  7000.000000 | C            |
|       10 |  4400.000000 | B            |
|       20 |  9500.000000 | C            |
|       30 |  4150.000000 | B            |
|       40 |  6500.000000 | C            |
|       50 |  3475.555556 | B            |
|       60 |  5760.000000 | B            |
|       70 | 10000.000000 | D            |
|       80 |  8955.882353 | C            |
|       90 | 19333.333333 | E            |
|      100 |  8600.000000 | C            |
|      110 | 10150.000000 | D            |
+----------+--------------+--------------+
12 rows in set (0.00 sec)
```

### 修改视图

2种方式。

#### 方式1

> 如果该视图存在，就修改，如果不存在，就创建新的视图。

```
create or replace view 视图名
as
查询语句;
```

##### 示例

```
CREATE OR REPLACE VIEW myv3
AS
  SELECT
    job_id,
    AVG(salary) javg
  FROM employees
  GROUP BY job_id;
```

#### 方式2

```
alter view 视图名
as 
查询语句;
```

##### 示例

```
ALTER VIEW myv3
AS
SELECT *
FROM employees;
```

### 删除视图

#### 语法

```
drop view 视图名1 [,视图名2] [,视图名n];
```

> 可以同时删除多个视图，多个视图名称之间用逗号隔开。

#### 示例

```
mysql> drop view myv1,myv2,myv3;
Query OK, 0 rows affected (0.00 sec)
```

### 查询视图结构

```
/*方式1*/
desc 视图名称;
/*方式2*/
show create view 视图名称;
```

如：

```
mysql> desc myv1;
+-----------------+-------------+------+-----+---------+-------+
| Field           | Type        | Null | Key | Default | Extra |
+-----------------+-------------+------+-----+---------+-------+
| last_name       | varchar(25) | YES  |     | NULL    |       |
| department_name | varchar(3)  | YES  |     | NULL    |       |
| job_title       | varchar(35) | YES  |     | NULL    |       |
+-----------------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
mysql> show create view myv1;
+------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+
| View | Create View                                                                                                                                                                                                                                                                                                                                                               | character_set_client | collation_connection |
+------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+
| myv1 | CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `myv1` AS select `t1`.`last_name` AS `last_name`,`t2`.`department_name` AS `department_name`,`t3`.`job_title` AS `job_title` from ((`employees` `t1` join `departments` `t2`) join `jobs` `t3`) where ((`t1`.`department_id` = `t2`.`department_id`) and (`t1`.`job_id` = `t3`.`job_id`)) | utf8                 | utf8_general_ci      |
+------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+
1 row in set (0.00 sec)
```

> `show create view`显示了视图的创建语句。

### 更新视图【基本不用】

> 视图的更新是更改视图中的数据，而不是更改视图中的sql逻辑。
>
> 当对视图进行更新后，也会对原始表的数据进行更新。
>
> 为了防止对原始表的数据产生更新，可以为视图添加只读权限，只允许读视图，不允许对视图进行更新。
>
> 一般情况下，极少对视图进行更新操作。

#### 示例

```sql
CREATE OR REPLACE VIEW myv4
  AS
  SELECT last_name,email
  from employees;

/*插入*/
insert into myv4 VALUES ('路人甲Java','javacode2018@163.com');
SELECT * from myv4 where email like 'javacode2018%';

/*修改*/
UPDATE myv4 SET last_name = '刘德华' WHERE last_name = '路人甲Java';
SELECT * from myv4 where email like 'javacode2018%';

/*删除*/
DELETE FROM myv4 where last_name = '刘德华';
SELECT * from myv4 where email like 'javacode2018%';
```

**注意：视图的更新我们一般不使用，了解即可。**

### 总结

1. 了解视图的用途及与表的区别。
2. 掌握视图的创建、使用、修改、删除。


参考：

https://dunwu.github.io/javacore/basics/java-enum.html#_1-%E7%AE%80%E4%BB%8B

https://blog.csdn.net/javazejian/article/details/71333103

https://www.bilibili.com/video/BV1Kb411W75N?from=search&seid=12776132743664963976

## 枚举的概述

枚举：在数学和计算机科学理论中，一个集的枚举是列出某些有穷序列集的所有成员的程序，或者是一种特定类型对象的计数。这两种类型经常（但不总是）重叠。

枚举类：类的对象只有有限个，确定的。我们称此类为枚举类，一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等。

枚举类型：jdk5新增`enum`关键字，被`enum`修饰的修饰的类型就是枚举类型。

## 枚举类型的简单使用

没有使用枚举类型的情况下，定义枚举类：

```java
//自定义枚举类
public class Season {
    //1.声明Season对象的属性:private final修饰
    private final String seasonName;
    private final String seasonDesc;

    //2.私化类的构造器,并给对象属性赋值
    private Season(String seasonName,String seasonDesc){
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    }

    //3.提供当前枚举类的多个对象：public static final的
    public static final Season SPRING = new Season("春天","春暖花开");
    public static final Season SUMMER = new Season("夏天","夏日炎炎");
    public static final Season AUTUMN = new Season("秋天","秋高气爽");
    public static final Season WINTER = new Season("冬天","冰天雪地");

    //4.其他诉求1：获取枚举类对象的属性
    public String getSeasonName() {
        return seasonName;
    }

    public String getSeasonDesc() {
        return seasonDesc;
    }
    //4.其他诉求2：提供toString()
    @Override
    public String toString() {
        return "Season{" +
                "seasonName='" + seasonName + '\'' +
                ", seasonDesc='" + seasonDesc + '\'' +
                '}';
    }
}
```

上述是没有使用枚举类型常见的定义方式，它存在许多不足

①不具备安全性，假设在使用的过程中忘记添加`final`关键字，就存在被他人修改的风险

②易混淆，如果定义了内容相同的变量，编译器不会发出警告。

使用枚举类型定义：

```java
//使用enum关键字枚举类
enum Season {
     SPRING, SUMMER, AUTUMN,WINTER
}
```

这相当简洁，一个值就代表一个实例，值之间使用逗号隔开，如果值重复编译器会给出提醒，后续也不会被修改，这相当滴安全啦。但是值好像没有给出季节的描述信息，该如何添加呢，请看下面代码

```java
//使用enum关键字枚举类
enum Season {
    //1.提供当前枚举类的对象，多个对象之间用","隔开，末尾对象";"结束
    SPRING("春天","春暖花开"),
    SUMMER("夏天","夏日炎炎"),
    AUTUMN("秋天","秋高气爽"),
    WINTER("冬天","冰天雪地");

    //2.声明Season对象的属性:private final修饰
    private final String seasonName;
    private final String seasonDesc;

    //3.私化类的构造器,并给对象属性赋值
    private Season(String seasonName,String seasonDesc){
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    }

    //4.其他诉求1：获取枚举类对象的属性
    public String getSeasonName() {
        return seasonName;
    }

    public String getSeasonDesc() {
        return seasonDesc;
    }

}
```

然后，枚举类有了，该如何使用，直接引用值就OK

```java
public static void main(String[] args) {
    System.out.println(Season.valueOf("SPRING"));
    for (Season season : Season.values()) {
        System.out.println(season.getSeasonName() + ",描述：" + season.seasonDesc);
    }
}
输出：
SPRING
春天,描述：春暖花开
夏天,描述：夏日炎炎
秋天,描述：秋高气爽
冬天,描述：冰天雪地
```

## 枚举类型的原理

我们以上述最简洁的那个枚举类型为例

```java
enum Season {
     SPRING, SUMMER, AUTUMN,WINTER
}
```

在终端`javac Season.java`运行生成`Season.class`字节码文件，再`javap Season.class`反编译一波：

```java
public final class enumeration.Season extends java.lang.Enum<enumeration.Season> {
  public static final enumeration.Season SPRING;
  public static final enumeration.Season SUMMER;
  public static final enumeration.Season AUTUMN;
  public static final enumeration.Season WINTER;
  public static enumeration.Season[] values();
  public static enumeration.Season valueOf(java.lang.String);
  static {};
}
```

有以下发现：

1. `enum`变成`class`了，说明`enum`枚举类本质也只是一个类，而且它是`java.lang.Enum`（该类是抽象类，后续分析）的子类
2. 只是该`class`前面带个`final`，说明这个类是最终类，<font color='red'>不可被继承</font>
3. 生成了四个静态常量，这可不就是我们前面写的短小精悍的四个季节嘛。编译器为我们加上`public static final enumeration.Season `，说明枚举的本质是<font color='red'>静态常量</font>
4. 编译器还给我们添加了两个方法`values()`和`valueOf()`，前面已简单使用过，后续继续分析它们用法。

## Enum抽象类

来看看``java.lang.Enum``的源码，并且对一些比较重要的方法分析一下

```java
public abstract class Enum<E extends Enum<E>>
        implements Comparable<E>, Serializable {
  	
    //此枚举常量的名称，在枚举声明中声明。
    private final String name;

    //返回此枚举常量的名称
    public final String name() {
        return name;
    }
	//枚举常量的序数
    private final int ordinal;

  	//返回此枚举常量的名称，在其枚举声明中对其进行声明
    public final int ordinal() {
        return ordinal;
    }

	//唯一的构造函数。程序员不能调用这个构造函数。它用于编译器响应枚举类型声明而发出的代码。
    protected Enum(String name, int ordinal) {
        this.name = name;
        this.ordinal = ordinal;
    }

	//返回枚举常量的名称，它包含在声明中
    public String toString() {
        return name;
    }
	//如果指定的对象等于此枚举常量，则返回true。
    public final boolean equals(Object other) {
        return this==other;
    }
	//返回此枚举常量的哈希码。
    public final int hashCode() {
        return super.hashCode();
    }
	//这保证了枚举永远不会被克隆，这是保持“单例”的必要条件。状态。
    protected final Object clone() throws CloneNotSupportedException {
        throw new CloneNotSupportedException();
    }
	//将此枚举与指定的对象进行比较以确定顺序。
    public final int compareTo(E o) {
        Enum<?> other = (Enum<?>)o;
        Enum<E> self = this;
        if (self.getClass() != other.getClass() && // optimization
            self.getDeclaringClass() != other.getDeclaringClass())
            throw new ClassCastException();
        return self.ordinal - other.ordinal;
    }

	//返回与此枚举常量的枚举类型相对应的 Class 对象
    @SuppressWarnings("unchecked")
    public final Class<E> getDeclaringClass() {
        Class<?> clazz = getClass();
        Class<?> zuper = clazz.getSuperclass();
        return (zuper == Enum.class) ? (Class<E>)clazz : (Class<E>)zuper;
    }

	//返回带指定名称的指定枚举类型的枚举常量。
    public static <T extends Enum<T>> T valueOf(Class<T> enumType,
                                                String name) {
        T result = enumType.enumConstantDirectory().get(name);
        if (result != null)
            return result;
        if (name == null)
            throw new NullPointerException("Name is null");
        throw new IllegalArgumentException(
            "No enum constant " + enumType.getCanonicalName() + "." + name);
    }

	//枚举类不能有finalize方法。
    protected final void finalize() { }

	//防止序列化和反序列化
    private void readObject(ObjectInputStream in) throws IOException,
        ClassNotFoundException {
        throw new InvalidObjectException("can't deserialize enum");
    }

    private void readObjectNoData() throws ObjectStreamException {
        throw new InvalidObjectException("can't deserialize enum");
    }
}

```


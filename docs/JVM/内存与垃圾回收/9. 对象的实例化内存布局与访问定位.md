> 深入理解java虚拟机 P48

## 对象的实例化

### **大厂面试题**

美团：

1. 对象在`JVM`中是怎么存储的？
2. 对象头信息里面有哪些东西？

蚂蚁金服：

二面：`java`对象头里有什么

---

###  创建对象的步骤

![img](https://note-java.oss-cn-beijing.aliyuncs.com/img/1615707516925-f3deac7e-49e8-4408-9e3d-8af09d1803be.jpeg)

1. **判断对象对应的类是否加载、链接、初始化**
   - 虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即<font color='red'>判断类元信息是否存在</font>）。
   - 如果该类没有加载，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的.class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。（即<font color='red'>执行相应的类加载过程</font>）

2. **为对象分配内存**

   首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是<font color='red'>引用变量</font>，仅分配引用变量空间即可，即<font color='red'>4个字节大小</font>。

   - 如果内存规整：<font color='red'>指针碰撞</font>
     - 如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。
     - 意思是所有用过的内存都被放在一边，空闲的内存被放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式——“指针碰撞”。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。（标记压缩算法）
   - 如果内存不规整
     - 如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是<font color='red'>空闲列表</font>方式来为对象分配内存。（标记清除算法）
     - 意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “<font color='red'>空闲列表</font>（Free List）”
   - 选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的<font color='red'>垃圾收集器是否带有空间压缩整理功能</font>决定 
     - 当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；
     - 而当使用CMS这种基于清除（Sweep）算法的收集器时，<font color='red'>理论上</font>就只能采用较为复杂的空闲列表来分配内存。  
       - 强调“理论上”是因为在CMS的实现里面，为了能在多数情况下分配得更快，设计了一个叫作<font color='red'>Linear Allocation Buffer</font>的分配缓冲区，通过空闲列表拿到一大块分配缓冲区之后，在它里面仍然可以使用指针碰撞方式来分配。

3. **处理并发问题**

   可能出现对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。

   - 对分配内存空间的动作进行同步处理——实际上虚拟机是采用<font color='red'>CAS</font>配上<font color='red'>失败重试</font>的方式保证更新操作的原子性。
   - 每个线程在Java堆中预先分配一小块内存——<font color='red'>本地线程分配缓冲</font>（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。是否使用TLAB，通过设置` -XX:+UseTLAB`参数来设置（区域加锁机制）

4. **初始化分配到的空间**
   
   - 内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。
   
   - 所有属性设置默认值，<font color='red'>保证对象实例字段在不赋值可以直接使用</font>
   - 给对象属性赋值的操作：
  - 属性的默认值初始化
     - 显示初始化/代码块初始化（在步骤6执行）
     - 构造器初始化（在步骤6执行）
   
5. **设置对象的对象头**

   - 将对象的所属类（即类的元数据信息）、对象的HashCode（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）和对象的GC分代年龄、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。

6. **执行init方法进行初始化**

   - 从虚拟机的视角来看，一个新的对象已经产生了。

   - 在Java程序的视角看来，对象创建才正式开始——构造函数，即Class文件中的\<init>方法还没执行。
     初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量
   - 因此一般来说（由字节码流中new指令后面是否跟随invokespecial指令所决定，Java编译器在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其它方式则不一定如此），new指令之后会接着就是执行\<init>方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完成被构造出来。

---

## 对象的内存布局

![img](https://note-java.oss-cn-beijing.aliyuncs.com/img/1615710413554-77efea78-332f-4ad7-9941-c14a4a80b45d.jpeg)

在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。 

HotSpot虚拟机对象的对象头部分包括两类信息。第一类是用于存储<font color='red'>对象自身的运行时数据</font>，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称它为“Mark Word”。
对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的最大限度，但对象头里的信息是与<font color='red'>对象自身定义的数据无关的额外存储成本</font>，考虑到虚拟机的空间效率，Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。
例如在32位的Hotspot虚拟机中，对象未被同步锁锁定的状态下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下的对象的存储内容如表：

| 存储内容                             | 标志位 | 状态               |
| ------------------------------------ | ------ | ------------------ |
| 对象哈希码、对象分代年龄             | 01     | 未锁定             |
| 指向锁记录的指针                     | 00     | 轻量级锁定         |
| 指向重量级锁的指针                   | 10     | 膨胀（重量级锁定） |
| 空，不需要记录信息                   | 11     | GC标记             |
| 偏向线程ID、偏向时间戳、对象分代年龄 | 01     | 可偏向             |

对象头的另外一部分是**类型指针**，即<font color='red'>对象指向它的类型元数据的指针</font>，Java虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。此外，如果对象是一个Java数组，那在对象头中还必须有一块<font color='red'>用于记录数组长度的数据</font>，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。

**实例数据部分**是<font color='red'>对象真正存储的有效信息</font>，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会受到虚拟机分配策略参数（`-XX：FieldsAllocationStyle`参数）和字段在Java源码中定义顺序的影响。 HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs），从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果HotSpot虚拟机的 `+XX：CompactFields`参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。 

**对齐填充**：HotSpot虚拟机的自动内存管理系统要求对象其实地址必须8字节的整数倍，即任何对象的大小都必须是8字节的整数倍。对象头部分已经被设计成8字节的倍数（1或者2），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

```java
public class CustomerTest {
    public static void main(String[] args) {
        Customer cust = new Customer();
    }
}
public class Customer{
    int id = 1001;
    String name;
    Account acct;

    {
        name = "匿名客户";
    }
    public Customer(){
        acct = new Account();
    }

}
class Account{

}
```

![img](https://note-java.oss-cn-beijing.aliyuncs.com/img/1615710675661-4920f7d4-26a1-49c1-bdc8-8ddf04f169d9.jpeg)

---

## 对象的访问定位

**JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？**

![img](https://note-java.oss-cn-beijing.aliyuncs.com/img/1615711506191-70197151-bda6-4884-a8f7-6e92724daf9c.png)

![img](https://note-java.oss-cn-beijing.aliyuncs.com/img/1615711554091-72e32e98-af8d-49b5-bc6d-f7c8b1f959d0.jpeg)

**句柄访问**

- Java堆中可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息
- 优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改
- ![img](https://note-java.oss-cn-beijing.aliyuncs.com/img/1615711730923-d7ab6d41-a138-45a5-9fe9-cfcddc6dcd97.jpeg)

**直接指针（HotSpot主要采用）**

- Java堆中对象的内存布局就必须考虑如何防止访问类型数据的相关信息。
- 优点：速度更快，节省了一次指针定位的时间开销。
- 缺点：对象被移动时需要修改 reference 的值
- Hotspot虚拟机主要使用的方式。（例外：如果使用Shenandoah收集器的话也会有一次额外的转发）

![img](https://note-java.oss-cn-beijing.aliyuncs.com/img/1615711772799-0072de94-b703-4d79-9c6d-22e9e626aa01.jpeg)
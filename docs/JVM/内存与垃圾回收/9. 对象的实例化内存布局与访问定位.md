## 对象的实例化

### **大厂面试题**

美团：

1. 对象在`JVM`中是怎么存储的？
2. 对象头信息里面有哪些东西？

蚂蚁金服：

二面：`java`对象头里有什么

---

###  创建对象的步骤

![img](https://note-java.oss-cn-beijing.aliyuncs.com/img/1615707516925-f3deac7e-49e8-4408-9e3d-8af09d1803be.jpeg)

1. **判断对象对应的类是否加载、链接、初始化**
   - 虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即<font color='red'>判断类元信息是否存在</font>）。
   - 如果该类没有加载，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的.class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。（即<font color='red'>执行相应的类加载过程</font>）

2. **为对象分配内存**

   首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是<font color='red'>引用变量</font>，仅分配引用变量空间即可，即<font color='red'>4个字节大小</font>。

   - 如果内存规整：<font color='red'>指针碰撞</font>
     - 如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。
     - 意思是所有用过的内存都被放在一边，空闲的内存被放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式——“指针碰撞”。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。（标记压缩算法）
   - 如果内存不规整
     - 如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是<font color='red'>空闲列表</font>方式来为对象分配内存。（标记清除算法）
     - 意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “<font color='red'>空闲列表</font>（Free List）”
   - 选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的<font color='red'>垃圾收集器是否带有空间压缩整理功能</font>决定

3. **处理并发问题**

   可能出现对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。

   - 对分配内存空间的动作进行同步处理——实际上虚拟机是采用<font color='red'>CAS</font>配上<font color='red'>失败重试</font>的方式保证更新操作的原子性。
   - 每个线程在Java堆中预先分配一小块内存——本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区完了，分配新的缓存区时才需要同步锁定。是否使用TLAB，通过设置` -XX:+UseTLAB`参数来设置（区域加锁机制）

4. **初始化分配到的空间**
   - 所有属性设置默认值，保证对象实例字段在不赋值可以直接使用
   - 给对象属性赋值的操作：
     - 属性的默认值初始化
     - 显示初始化/代码块初始化（在步骤6执行）
     - 构造器初始化（在步骤6执行）

5. **设置对象的对象头**
   
- 将对象的所属类（即类的元数据信息）、对象的HashCode（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）和对象的GC分代年龄、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。
   
6. **执行init方法进行初始化**

   - 从虚拟机的视角来看，一个新的对象已经产生了。

   - 在Java程序的视角看来，对象创建才正式开始——构造函数，即Class文件中的\<init>方法还没执行。
     初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量
   - 因此一般来说（由字节码流中new指令后面是否跟随invokespecial指令所决定，Java编译器在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其它方式则不一定如此），new指令之后会接着就是执行\<init>方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完成被构造出来。

---

## 对象的内存布局

![img](https://note-java.oss-cn-beijing.aliyuncs.com/img/1615710413554-77efea78-332f-4ad7-9941-c14a4a80b45d.jpeg)

Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存存储尽量多的数据，根据<font color='red'>对象的状态</font>复用自己的存储空间。

例如在32位的Hotspot虚拟机中，对象未被同步锁锁定的状态下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下的对象的存储内容如表：

| 存储内容                             | 标志位 | 状态               |
| ------------------------------------ | ------ | ------------------ |
| 对象哈希码、对象分代年龄             | 01     | 未锁定             |
| 指向锁记录的指针                     | 00     | 轻量级锁定         |
| 指向重量级锁的指针                   | 10     | 膨胀（重量级锁定） |
| 空，不需要记录信息                   | 11     | GC标记             |
| 偏向线程ID、偏向时间戳、对象分代年龄 | 01     | 可偏向             |

对齐填充：HotSpot虚拟机的自动内存管理系统要求对象其实地址必须8字节的整数倍，即任何对象的大小都必须是8字节的整数倍。对象头部分已经被设计成8字节的倍数（1或者2），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

```java
public class CustomerTest {
    public static void main(String[] args) {
        Customer cust = new Customer();
    }
}
public class Customer{
    int id = 1001;
    String name;
    Account acct;

    {
        name = "匿名客户";
    }
    public Customer(){
        acct = new Account();
    }

}
class Account{

}
```



![img](https://note-java.oss-cn-beijing.aliyuncs.com/img/1615710675661-4920f7d4-26a1-49c1-bdc8-8ddf04f169d9.jpeg)

---

## 对象的访问定位

**JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？**

![img](https://note-java.oss-cn-beijing.aliyuncs.com/img/1615711506191-70197151-bda6-4884-a8f7-6e92724daf9c.png)

![img](https://note-java.oss-cn-beijing.aliyuncs.com/img/1615711554091-72e32e98-af8d-49b5-bc6d-f7c8b1f959d0.jpeg)

**句柄访问**

- Java堆中可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息
- 优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改
- ![img](https://note-java.oss-cn-beijing.aliyuncs.com/img/1615711730923-d7ab6d41-a138-45a5-9fe9-cfcddc6dcd97.jpeg)

**直接指针（HotSpot主要采用）**

- Java堆中对象的内存布局就必须考虑如何防止访问类型数据的相关信息。
- 优点：速度更快，节省了一次指针定位的实践开销。
- 缺点：对象被移动时需要修改 reference 的值
- Hotspot虚拟机主要使用的方式。（例外：如果使用Shenandoah收集器的话也会有一次额外的转发）

![img](https://note-java.oss-cn-beijing.aliyuncs.com/img/1615711772799-0072de94-b703-4d79-9c6d-22e9e626aa01.jpeg)
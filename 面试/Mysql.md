## MySQL

### 1.主键、外键有什么区别?

主键：用来表示一条记录的唯一表示，不能有重复，不允许为空，默认为聚集索引，用来保证数据完整性。

外键：表的某列是另一表 的主键，外键可以重复，可以是空值，用来和其他表建立关联用的

### 2.什么是范式化?

范式化是指数据库设计的规范，通过使用不同层次的范式，达到在数据库设计中，减少数据冗余，增进数据一致性的目的。

### 3.什么是反范式化?

反范式化是指为了查询效率的考虑，把原来符合第三范式的表适当增加冗余，以达到优化查询效率的目的，反范式化是一种以空间换取时间的操作

### 4.三范式分别是指哪三个?

第一范式（1NF）: 列的原子性（同一列不能有多个值）

第二范式（2NF）:消除了非主属性对于码的部分函数依赖（满足1NF且非主键列都完全函数依赖于主键）

- 必须满足1NF
- 必须有一个主键，且没有包含在主键中的列必须完全依赖于主键，而不能只依赖主键的一部分

第三范式（3NF）:消除了非主属性对于码的传递函数依赖（满足2NF且非主属性列都不传递依赖于主键）

- 满足2NF
- 不能有传递的依赖关系。换句话说，表中的每一列和主键直接相关，不能是间接相关的。再换句话说，通过主键就能直接定位到每一列，而不能是间接才能定位到

BCNF:消除了主属性对于码的部分函数依赖和传递函数依赖（即满足3NF，并且主属性之间没有依赖关系）

- 满足3NF
- 主属性之间没有依赖关系。

### 5.范式化有什么优缺点?

优点：

- 范式化更新操作通常比反范式化要快。
- 当数据较好的范式化时，就只有很少或者没有重复数据，所以，只需要修改更少的数据。
- 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快。
- 很少有多余的数据意味着检索列表数据更少需要distinct或者group by 语句。

缺点：

- 范式化设计schema通常需要关联。稍微复杂一些的查询语句在符合范式的schema上都可能需要至少一次关联，也许更多。这样做代价昂贵，也可能使一些索引策略无效。例如，范式化可能将列放在不同的表中，而这些列在同一个表中可以数据同一个索引。

### 6.反范式化有什么优缺点?

优点：

- 所有数据都在一张表中，可以很好地避免关联。
- 如果不需要关联表，则对大部分查询最差情况——即没有使用索引——全表扫描。当数据币内存大时这可能比关联要快很多， 这样避免了随机I/O。
- 单独的表也能使用更有效的索引策略。

缺点：

- 表格内的冗余较多
- 删除数据时候会造成表有些有用的信息丢失

### 7.数据库设计时怎么使用范式?

在真实环境中很少会极端地使用范式化或者反范式化的schema。而是可能使用部分范式化的schema、缓存表、以及其它技巧。最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定的列。在Mysql5.0和更新版本中，可以使用触发器更新缓存值，这使得实现这样的方案变得更简单。

### 8.什么是事务?

事务就是一组原子性的 SQL 查询，或者说是一个独立的工作单元。如果数据库引擎能够成功地队数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。

### 9.事务有哪几个特性?

原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的操作要么都做，要么都不做。

一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。

隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

持久性（durability）。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系:

- 只有满足一致性，事务的执行结果才是正确的。
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久化是为了能应对数据库崩溃的情况。

### 10.什么是脏读、幻读、不可重复读?

脏读（Dirty Read）：一个事务可以读取另一个事务未提交的数据。

不可重复读：事务 T1 读到某行；事务 T2 修改或删除这行，提交事务；T1 重新读取发现这行数据已经被修改或删除。

幻读：事务 T1 读取了 N 行；事务 T2 在事务 T1 读取的条件范围内生成了一行或多行数据；T1 重新读取获得与之前不同集合的行数据。（InnoDB 和 XtraDB 存储引擎通过多版本并发控制）解决了幻读的问题

### 11.MySQL有哪些事务隔离级别?

- 读未提交（Read Uncommitted）：是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。会出现脏读，幻读，不可重复读，所有并发问题都可能遇到。
- 读已提交（Read Committed）：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。不会出现脏读现象，但是会出现幻读，不可重复读。
- 可重复读（Repeatable Read）：这种事务隔离级别保证了同一事务中多次读取同样记录的结果是一致的，可以防止脏读，不可重复读，但是可能会出现幻读。
- 串行化（Serializable）：Serializable会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。防止脏读、不可重复读、幻象读。

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| ---------------------------- | ---- | ---------- | ---- | ------ |
| 读未提交（read-uncommitted） | 是   | 是         | 是   | 否     |
| 不可重复读（read-committed） | 否   | 是         | 是   | 否     |
| 可重复读（repeatable-read）  | 否   | 否         | 是   | 否     |
| 串行化（serializable）       | 否   | 否         | 否   | 是     |

### 12.MySQL默认的事务隔离级别是?

可重复读

### 13.MySQL事务默认提交模式是?

可重复读

### 14.MySQL事务如何开启、禁用自动提交?

直接用 SET 来改变提交模式:

- SET AUTOCOMMIT=0 禁止自动提交
- SET AUTOCOMMIT=1 开启自动提交

### 15.MySQL中哪些存储引擎支持事务?

在mysql中用的最多的存储引擎有：innodb，bdb，myisam ,memory 等。其中innodb和bdb支持事务而myisam等不支持事务。

### 16.MySQL 切换数据库用什么命令?

show databases; 显示所有已经存在的数据库

create database test； 创建名字为test的数据库

drop database test； 删除名字为test的数据库

use test；使用名字为test的数据库

### 17.MySQL 查看所有数据库用什么命令?

show databases;

### 18.MySQL 查看当前库所有表用什么命令?

show tables； 显示这个数据库中的所有数据表

describe player; 显示player这张表的属性

### 19.什么是索引?

MySQL官方对索引的定义为：**索引（INDEX）是帮助MySQL高效获取数据的数据结果。**

从而可以获得索引的本质：**索引是排好序的快速查找数据结构。**

### 20.索引有什么用?

索引的目的在于提高查询效率，可以类比字典的目录

### 21.索引为什么能提高查询效率?

索引就是通过事先排好序，从而在查找时可以应用二分查找等高效率的算法。

一般的顺序查找，复杂度为O(n)，而二分查找复杂度为O(log2n)。当n很大时，二者的效率相差及其悬殊。

### 22.索引的设计有哪些原则?

1. 选择唯一性索引

   唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。

2. 为经常需要排序、分组和联合操作的字段建立索引

   经常需要 ORDER BY、GROUP BY、DISTINCT 和 UNION 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。

3. 为常作为查询条件的字段建立索引

   如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。

   注意：常查询条件的字段不一定是所要选择的列，换句话说，最适合索引的列是出现在 WHERE 子句中的列，或连接子句中指定的列，而不是出现在 SELECT 关键字后的选择列表中的列。

4. 限制索引的数目

   索引的数目不是“越多越好”。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。在修改表的内容时，索引必须进行更新，有时还可能需要重构。因此，索引越多，更新表的时间就越长。

   如果有一个索引很少利用或从不使用，那么会不必要地减缓表的修改速度。此外，MySQL 在生成一个执行计划时，要考虑各个索引，这也要花费时间。创建多余的索引给查询优化带来了更多的工作。索引太多，也可能会使 MySQL 选择不到所要使用的最佳索引。

5. 尽量使用数据量少的索引

   如果索引的值很长，那么查询的速度会受到影响。例如，对一个 CHAR(100) 类型的字段进行全文检索需要的时间肯定要比对 CHAR(10) 类型的字段需要的时间要多。

6. 数据量小的表最好不要使用索引

   由于数据较小，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。

7. 尽量使用前缀来索引

   如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。

8. 删除不再使用或者很少使用的索引

   表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。应该定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。

### 23.索引对数据库有什么负面影响?

- 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的。
- 虽然索引大大提高了查询速度，但是同时会降低表的更新速度，例如对表频繁的进行`INSERT`、`UPDATE`和`DELETE`。因为更新表的时候，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加的索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。
- 索引只是提高效率的一个因素，如果MySQL有大数据量的表，就需要花时间研究建立最优秀的索引。

### 24.什么情况下应不建或少建索引?

- 记录太少的表。
- 经常增删改的表。
- 频繁更新的字段不适合创建索引。
- Where条件里用不到的字段不创建索引。
- 数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。
  - 假如一个表有10万行记录，有一个字段A只有true和false两种值，并且每个值的分布概率大约为50%，那么对A字段建索引一般不会提高数据库的查询速度。
  - 索引的选择性是指索引列中不同值的数目与表中记录数的比。如果一个表中有2000条记录，表索引列有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，这个索引的效率就越高。

### 25.MySQL 索引的种类有哪些?

按数据结构分类可分为：B+tree索引、Hash索引、Full-text索引。
按物理存储分类可分为：聚簇索引、二级索引（辅助索引）。
按字段特性分类可分为：主键索引、普通索引、前缀索引。
按字段个数分类可分为：单列索引、联合索引（复合索引、组合索引）。

> https://segmentfault.com/a/1190000037683781

### 26.MySQL 索引命名有什么规范?

主键索引名为 pk字段名； 唯一索引名为 uk字段名； 普通索引名则为 idx_字段名 。

说明： pk_ 即 primary key； uk_ 即 unique key

### 27.MySQL 二级索引是什么?

二级索引：叶子节点中存储主键值，每次查找数据时，根据索引找到叶子节点中的主键值，根据主键值再到聚簇索引中得到完整的一行记录。

### 28.MySQL有了聚簇索引为啥还要二级索引?

聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。

聚簇索引的叶子节点存储了一行完整的数据，而二级索引只存储了主键值，相比于聚簇索引，占用的空间要少。当我们需要为表建立多个索引时，如果都是聚簇索引，那将占用大量内存空间，所以InnoDB中主键所建立的是聚簇索引，而唯一索引、普通索引、前缀索引等都是二级索引。

### 29.MySQL 索引最左匹配原则怎么理解?

最佳左前缀法则：如果索引是多字段的复合索引，要遵守最佳左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的字段。

MySQL 建立联合索引的规则是这样的，它会首先根据联合索引中最左边的、也就是第一个字段进行排序，在第一个字段排序的基础上，再对联合索引中后面的第二个字段进行排序，依此类推。

综上，第一个字段是绝对有序的，从第二个字段开始是无序的，这就解释了为什么直接使用第二字段进行条件判断用不到索引了（从第二个字段开始，无序，无法走 B+ Tree 索引）！这也是 MySQL 在联合索引中强调最左前缀匹配原则的原因。

> https://blog.csdn.net/u013568373/article/details/93891531

### 30.MySQL 中的隐藏索引是什么?

MySQL支持隐藏索引，即在不改变实际索引结构的情况下，优化器不使用该索引。这个特性可以使用在任何非主键上。

> https://www.jianshu.com/p/eac8872e50a9

### 31.MySQL 索引实现是什么数据结构?

B+树

### 32.MySQL一个表最多创建多少个索引?

索引个数没有限制

一个表最多可以包含64个二级索引。对于多列索引，最多允许16列。超过限制将返回错误。

### 33.MySQL 索引最多包含多少个列?

16

### 34.MySQL索引为什么选用 B+Tree?

B+Tree是在B-Tree基础上演进而来的。与之不同的是B+Tree的数据页只存储在叶子节点中，并且叶子节点之间通过指针相连，为双向链表结构。

1. 充分利用空间局部性原理，适合磁盘存储。
2. 树的高度很低，能够在存储大量数据情况下，进行较少的磁盘IO【见下文介绍】。
3. 能够很好支持单值，范围查询，有序性查询。
4. 索引和数据分开存储，让更多的索引存储在内存中。

### 35.MySQL B+ 树索引和哈希索引的区别?

- 如果是<font color='red'>等值查询，那么哈希索引明显有绝对优势</font>，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；
- 从示意图中也能看到，<font color='red'>如果是范围查询检索，这时候哈希索引就毫无用武之地了</font>，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；
- 同理，<font color='red'>哈希索引也没办法利用索引完成排</font>序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；
- <font color='red'>哈希索引也不支持多列联合索引的最左匹配规则；</font>
- B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，<font color='red'>在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。</font>

在MySQL中，只有HEAP/MEMORY引擎表才能显式支持哈希索引（NDB也支持，但这个不常用），InnoDB引擎的自适应哈希索引（adaptive hash index）不在此列，因为这不是创建索引时可指定的。
还需要注意到：HEAP/MEMORY引擎表在mysql实例重启后，数据会丢失。

### 36.MySQL B+树的一个节点为多大?

1页，16k

首先InnoDB的B+树中，非叶子节点存的是key + 指针；叶子节点存的是数据行。
对于叶子节点，如果一行数据大小为1k，那么一页就能存16条数据；对于非叶子节点，如果key使用的是bigint，则为8字节，指针在mysql中为6字节，一共是14字节，则16k能存放 16 * 1024 / 14 = 1170 个索引指针。于是可以算出，对于一颗高度为2的B+树，根节点存储索引指针节点，那么它有1170个叶子节点存储数据，每个叶子节点可以存储16条数据，一共 1170 x 16 = 18720 条数据。而对于高度为3的B+树，就可以存放 1170 x 1170 x 16 = 21902400 条数据（两千多万条数据），也就是对于两千多万条的数据，我们只需要高度为3的B+树就可以完成，通过主键查询只需要3次IO操作就能查到对应数据。所以在 InnoDB 中B+树高度一般为3层时，就能满足千万级的数据存储，所以一个节点为1页，也就是16k是比较合理的

### 37.MySQL 索引在哪些情况下会失效?

- 条件中带有以通配符%开头的 like
-  当使用or关键字时，or语句前后没有同时使用索引，该索引失效，只有当or左右查询字段均为索引时，才会生效。
- 在索引字段上使用函数、计算、类型转换
- 在索引字段上使用not及运算符
- 使用`!=`或者`<>`
- `is null`、`is not null`也无法使用索引
- 字符串不加单引号索引失效。
- 使用组合索引时，如果查询条件不包括该组合索引全部字段或查询条件不是该组合索引左边第一个字段时，索引失效。(最左匹配)
- 全表扫描的速度大于索引速度时，索引失效。如表内数据极少

### 38.MySQL 默认最大的连接数是多少?

> https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_max_connections

[`max_connections`](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_max_connections)

| Command-Line Format                                          | `--max-connections=#` |
| :----------------------------------------------------------- | --------------------- |
| System Variable                                              | `max_connections`     |
| Scope                                                        | Global                |
| Dynamic                                                      | Yes                   |
| [`SET_VAR`](https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-set-var) Hint Applies | No                    |
| Type                                                         | Integer               |
| Default Value                                                | `151`                 |
| Minimum Value                                                | `1`                   |
| Maximum Value                                                | `100000`              |

### 39.MySQL数据库引擎怎么选择?

| 特性         | MyISAM | InnoDB | MEMORY |
| ------------ | ------ | ------ | ------ |
| 存储限制     | 有     | 支持   | 有     |
| 事务安全     | 不支持 | 支持   | 不支持 |
| 锁机制       | 表锁   | 行锁   | 表锁   |
| B树索引      | 支持   | 支持   | 支持   |
| 哈希索引     | 不支持 | 不支持 | 支持   |
| 全文索引     | 支持   | 不支持 | 不支持 |
| 集群索引     | 不支持 | 支持   | 不支持 |
| 数据缓存     |        | 支持   | 支持   |
| 索引缓存     | 支持   | 支持   | 支持   |
| 数据可压缩   | 支持   | 不支持 | 不支持 |
| 空间使用     | 低     | 高     | N/A    |
| 内存使用     | 低     | 高     | 中等   |
| 批量插入速度 | 高     | 低     | 高     |
| 支持外键     | 不支持 | 支持   | 不支持 |

1) MyISAM

在 MySQL 5.1 版本及之前的版本，MyISAM 是默认的存储引擎。
MyISAM 存储引擎不支持事务和外键，所以访问速度比较快。如果应用主要以读取和写入为主，只有少量的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择 MyISAM 存储引擎是非常适合的。
MyISAM 是在 Web 数据仓储和其他应用环境下最常使用的存储引擎之一。

2) InnoDB

MySQL 5.5 版本之后默认的事务型引擎修改为 InnoDB。
InnoDB 存储引擎在事务上具有优势，即支持具有提交、回滚和崩溃恢复能力的事务安装，所以比 MyISAM 存储引擎占用更多的磁盘空间。

如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包括很多的更新、删除操作，那么 InnoDB 存储引擎是比较合适的选择。
InnoDB 存储引擎除了可以有效地降低由于删除和更新导致的锁定，还可以确保事务的完整提交（Commit）和回滚（Rollback），对于类似计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB 都是合适的选择。

 3) MEMORY

MEMORY 存储引擎将所有数据保存在 RAM 中，所以该存储引擎的数据访问速度快，但是安全上没有保障。

MEMORY 对表的大小有限制，太大的表无法缓存在内存中。由于使用 MEMORY 存储引擎没有安全保障，所以要确保数据库异常终止后表中的数据可以恢复。

如果应用中涉及数据比较少，且需要进行快速访问，则适合使用 MEMORY 存储引擎。

### 40.MySQL 默认数据库引擎是什么?

InnoDB

### 41.MySQL引擎MyISAM和 InnoDB的区别?

**MyISAM：**

每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义，数据文件的扩展名为.MYD (MYData)，索引文件的扩展名是.MYI (MYIndex)。

MyISAM表格可以被压缩，而且它们支持全文搜索。不支持事务，而且也不支持外键。如果事物回滚将造成不完全回滚，不具有原子性。在进行updata时进行表锁，并发量相对较小。如果执行大量的SELECT，MyISAM是更好的选择。

MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小

MyISAM缓存在内存的是索引，不是数据。而InnoDB缓存在内存的是数据，相对来说，服务器内存越大，InnoDB发挥的优势越大。

**优点：**查询数据相对较快，适合大量的select，可以全文索引。

**缺点：**不支持事务，不支持外键，并发量较小，不适合大量update

**InnoDB：**

这种类型是事务安全的。它与BDB类型具有相同的特性,它们还支持外键。InnoDB表格速度很快。具有比BDB还丰富的特性,因此如果需要一个事务安全的存储引擎，建议使用它。在update时表进行行锁，并发量相对较大。如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。

**优点：**支持事务，支持外键，并发量较大，适合大量update

**缺点：**查询数据相对较快，不适合大量的select

对于支持事物的InnoDB类型的表，影响速度的主要原因是AUTOCOMMIT默认设置是打开的，而且程序没有显式调用BEGIN 开始事务，导致每插入一条都自动Commit，严重影响了速度。可以在执行sql前调用begin，多条sql形成一个事物（即使autocommit打开也可以），将大大提高性能。

**基本的差别为**：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。

MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持已经外部键等高级数据库功能。

### 42.MySQL InnoDB引擎的物理存储文件?

.frm文件

.ibd文件和.ibdata文件：

这两种文件都是存放innodb数据的文件，之所以用两种文件来存放innodb的数据，是因为innodb的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据。

独享表空间存储方式使用.ibd文件，并且每个表一个ibd文件

共享表空间存储方式使用.ibdata文件，所有表共同使用一个ibdata文件

> https://blog.csdn.net/qq_42112448/article/details/105270081
>
> https://baijiahao.baidu.com/s?id=1660374685951447632&wfr=spider&for=pc

### 43.MySQL MyISAM引擎的物理存储文件?

（1）frm文件：存储表的定义数据

（2）MYD文件：存放表具体记录的数据

（3）MYI文件：存储索引

frm和MYI可以存放在不同的目录下。MYI文件用来存储索引，但仅保存记录所在页的指针，索引的结构是B+树结构。

### 44.char和 varchar 的区别?

- char 是一种固定长度的字符串类型
- varchar 是一种可变长度的字符串类型

### 45.常用的 SQL JOIN 连接及区别?

![七种JOIN理论](https://note-java.oss-cn-beijing.aliyuncs.com/img/20200801212011559.jpg)

### 46.SQL 中的笛卡尔积是什么?

笛卡尔积，又叫cross join，是SQL中两表连接的一种方式。
假如A表中的数据为m行，B表中的数据有n行，那么A和B做笛卡尔积，结果为m*n行。

### 47.如何避免 SQL 出现笛卡尔积?

两表关联的时候通过最小的粒度关联（唯一字段）

### 48.union和 union all的区别?

union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序（根据主键升序排序）；

union all: 对两个结果集进行并集操作, 包括重复行, 即所有的结果全部显示, 不管是不是重复。

### 49.为什么不建议用 union而用 union all?

union all只是合并查询结果，并不会进行去重和排序操作，在没有去重的前提下，使用union all的执行效率要比union高

### 50.MySQL的drop、delete、truncate区别?

- drop (删除表)：删除内容和定义，释放空间，简单来说就是**把整个表去掉**，以后要新增数据是不可能的，除非新增一个表。

  drop语句将删除表的结构被依赖的约束（constrain），触发器（trigger）索引（index），依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。

  如果要删除表定义及其数据，请使用 drop table 语句。

- truncate (清空表中的数据)：删除内容、释放空间但不删除定义(**保留表的数据结构**)，与drop不同的是，只是清空表数据而已。

  注意：truncate不能删除具体行数据，要删就要把整个表清空了。

- delete (删除表中的数据)：delete 语句用于**删除表中的行**。delete语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存，以便进行进行回滚操作。

  truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）

  truncate table 删除表中的所有行，但表结构及其列、约束、索引等保持不变。

  对于由foreign key约束引用的表，不能使用truncate table ，而应使用不带where子句的delete语句。由于truncate table 记录在日志中，所以它不能激活触发器。

  delete语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，**事务提交之后才生效**；如果有相应的 trigger，执行的时候将被触发。

  **truncate、drop 是数据库定义语言(ddl)，操作立即生效**，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。

  **如果有自增列，truncate方式删除之后，自增列的值会被初始化，delete方式要分情况（如果数据库被重启了，自增列值也会被初始化，数据库未被重启，则不变）**

- **如果要删除表定义及其数据，请使用 drop table 语句**

- **安全性：小心使用 drop 和 truncate，尤其没有备份的时候，否则哭都来不及**

- **删除速度，一般来说: drop> truncate > delete**

### 51.MySQL怎么实现分页查询?

```sql
select * from table limit (pageNo-1)*pageSize, pageSize;
```

### 52.MySQL的高可用方案有哪些?

https://zhuanlan.zhihu.com/p/25960208

### 53.如何分析一条 SQL 语句的执行计划和性能?

explain sql语句

### 54.MySQL 查询优化有哪些方法?

https://segmentfault.com/a/1190000011330649

### 55.MySQL为什么不建议默认 nul值?

1. NULL作为布尔值的时候，不为1也不为0

2. 任何值和NULL使用运算符（>、<、>=、<=、!=、<>）或者（in、not in、any/some、all），返回值都为NULL

3. 当IN和NULL比较时，无法查询出为NULL的记录

4. 当NOT IN 后面有NULL值时，不论什么情况下，整个sql的查询结果都为空

5. 判断是否为空只能用IS NULL、IS NOT NULL

6. count(字段)无法统计字段为NULL的值，count(\*)可以统计值为null的行

7. 当字段为主键的时候，字段会自动设置为not null

8. NULL导致的坑让人防不胜防，强烈建议创建字段的时候字段不允许为NULL，给个默认值

9. MySQL 中存在 NULL 值的列也是走索引的

   如果查询中包含null，对mysql来说更难优化，因为可为null的列使得索引，索引统计和值比较都更复杂。可为null的列会使用更多的存储空间，在mysql里也需要特殊处理。当可为null的列被索引时，每个索引记录需要一个额外的字节。
   如果在计划列上建立索引，就应该尽量避免设计成可为null的列

### 56.MySQL为什么尽量选择最小数据类型?

更小的数据类型通常更快，耗用更少的cpu，磁盘。

### 57.MySQL模糊查询会导致索引失效吗?

使用like关键字模糊查询时，% 放在前面索引不起作用，只有“%”不在第一个位置，索引才会生效（like ‘%文’–索引不起作用）

### 58.MySQL模糊查询怎么只匹配一个字符?

`like '_'`

### 59.MySQL 模糊查询怎么匹配多个字符?

`like '%'`

### 60.MySQL怎么记录慢查询语句?

https://www.cnblogs.com/kerrycode/p/5593204.html

### 61.MySQL支持查询结果缓存吗?

MySQL 4.0推出，5.6中默认禁用，5.7中被deprecated（废弃），8.0版本被Removed，

> https://segmentfault.com/a/1190000038554542

### 62.怎么理解数据库中的乐观锁?

乐观锁（ Optimistic Locking ） 是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。

相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是CAS和记录数据版本解决ABA问题。

> https://www.cnblogs.com/kyoner/p/11318979.html

### 63.怎么理解数据库中的悲观锁?

当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。

这种借助数据库锁机制在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。

之所以叫做悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式。我们一般认为数据被并发修改的概率比较大，所以需要在修改之前先加锁。

悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。

### 64.MySQL中的for update 锁的是什么?

用法： select … for update;

例如：select * from goods where id = 1 for update;

排他锁的申请前提：没有线程对该结果集中的任何行数据使用排他锁或共享锁，否则申请会阻塞。

for update仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。

> https://blog.csdn.net/claram/article/details/54023216

### 65.MySQL中的 MVCC 是指什么?

**多版本并发控制**技术的英文全称是 **Multiversion Concurrency Control**，简称 **MVCC**。

**多版本并发控制（MVCC）** 是通过保存数据在某个时间点的快照来实现并发控制的。也就是说，不管事务执行多长时间，事务内部看到的数据是不受其它事务影响的，根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

> https://segmentfault.com/a/1190000037557620

### 66.MySQL InnoDB的 MVCC 实现机制?

InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。一个保存了行的事务ID（DB_TRX_ID），一个保存了行的回滚指针（DB_ROLL_PTR）。每开始一个新的事务，都会自动递增产生一个新的事务id。事务开始时刻的会把事务id放到当前事务影响的行事务id中，当查询时需要用当前事务id和每行记录的事务id进行比较。

### 67.MySQL中的 MVCC支持的隔离级别?

多版本并发控制（MVCC） 在一定程度上实现了读写并发，它只在可重复读（REPEATABLE READ） 和 提交读（READ COMMITTED） 两个隔离级别下工作。其他两个隔离级别都和 MVCC 不兼容，因为 未提交读（READ UNCOMMITTED），总是读取最新的数据行，而不是符合当前事务版本的数据行。而 可串行化（SERIALIZABLE） 则会对所有读取的行都加锁。

### 68.MySQL支持哪三种级别的锁?

在关系型数据库中，可以按照锁的粒度把数据库锁分为**行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )**。

MySQL锁可以按模式分类为：乐观锁与悲观锁。按粒度分可以分为全局锁、表级锁、页级锁、行级锁。按属性可以分为：共享锁、排它锁。按状态分为：意向共享锁、意向排它锁。按算法分为：间隙锁、临键锁、记录锁。

### 69.MySQL InnoDB支持什么锁?

MyISAM采用表级锁(table-level locking)。

InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁

### 70.MySQL中的表锁有哪些?

> https://www.cnblogs.com/xiaolincoding/p/15146872.html

1. 元数据锁（MDL）;
2. 意向锁；
3. AUTO-INC 锁；

### 71.MySQL 中的行锁有哪些?

共享锁、排他锁

### 72.MySQL中的意向锁有什么用?

意向锁的目的是为了快速判断表里是否有记录被加锁。

> https://juejin.cn/post/6844903666332368909

### 73.MySQL 中的意向锁的分类?

- 意向共享锁

  （intention shared lock, IS）：事务有意向对表中的某些行加

  共享锁

  （S锁）

  ```
  -- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。
  SELECT column FROM table ... LOCK IN SHARE MODE;
  复制代码
  ```

- 意向排他锁

  （intention exclusive lock, IX）：事务有意向对表中的某些行加

  排他锁

  （X锁）

  ```
  -- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。
  SELECT column FROM table ... FOR UPDATE;
  复制代码
  ```

即：``意向锁是有数据引擎自己维护的，用户无法手动操作意向锁``，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。

### 74.MySQL中的意向锁是表锁还是行锁?

不与行锁互斥的表锁

### 75.MySQL中的自增锁有什么用?

在为某个字段声明 `AUTO_INCREMENT` 属性时，之后可以在插入数据时，可以不指定该字段的值，数据库会自动给该字段赋值递增的值，这主要是通过 AUTO-INC 锁实现的。

AUTO-INC 锁是特殊的表锁机制，锁**不是再一个事务提交后才释放，而是在执行完插入语句后就会立即释放**。

> https://www.cnblogs.com/xiaolincoding/p/15146872.html

### 76.MySQL行锁是锁的是什么?

MySQL的行锁是通过索引加载的，也就是说，行锁是加在索引响应的行上的，要是对应的SQL语句没有走索引，则会全表扫描，行锁则无法实现，取而代之的是表锁，此时其它事务无法对当前表进行更新或插入操作。

### 77.MySQL行锁实现的几种算法?

- Record Lock: 单个记录上的锁
- Gap Lock: 间隙锁，锁定一个范围，但不包括记录本上
- Next-Key Lock: Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身

> https://juejin.cn/post/6844904090594443278
>
> https://juejin.cn/post/6844903735500472333

### 78.MySQL什么情况会发生死锁?

两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。

> https://blog.csdn.net/qq_35549286/article/details/108831923

### 79.MySQL产生死锁有哪些必要条件?

（1） 互斥条件：一个资源每次只能被一个进程使用。 
（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 
（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 
（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 
这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 

### 80.MySQL死锁怎么排查?

### 81.MySQL 如何解决死锁?

1. 检查到死锁的循环依赖时，立即返回一个错误
2. 当查询的时间达到锁等待超时的设定后放弃锁请求
3. 将持有最少行级排他锁的事务进行回滚

死锁检测的原理是构建一个以事务为顶点、锁为边的有向图，判断有向图是否存在环，存在即有死锁。

### 82.MySQL 如何避免死锁?

在程序中，操作多张表时，尽量以相同的顺序来访问（避免形成等待环路）；

批量操作单张表数据的时候，先对数据进行排序（避免形成等待环路）；

申请足够级别的锁，如果要操作数据，就申请排它锁；

尽量使用索引访问数据，避免没有 where 条件的操作，避免锁表；

如果可以，大事务化成小事务；

使用等值查询而不是范围查询查询数据，命中记录，避免间隙锁对并发的影响。

> https://juejin.cn/post/6844904072760262669

### 83.MySQL和 MariaDB的区别?

### 84.MySQL日志undo和redo的区别?

undo 日志用于记录事务开始前的状态，用于事务失败时的回滚操作；redo 日志记录事务执行后的状态，用来恢复未写入 data file 的已成功事务更新的数据。例如某一事务的事务序号为 T1，其对数据 X 进行修改，设 X 的原值是 0，修改后的值为 1，那么 Undo 日志为 <T1, X, 0>，Redo 日志为 < T1, X, 1>。

> https://juejin.cn/post/6860252224930070536

### 85.MySQL单表的最大记录数是多少?

MySQL本身并没有对单表最大记录数进行限制，但是从性能考虑，记录数过多肯定是有一定影响的

阿里巴巴《Java 开发手册》提出单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表

### 86.什么是表分区?

分区是一种表的设计模式，通俗地讲表分区是将一大表，根据条件分割成若干个小表。但是对于应用程序来讲，分区的表和没有分区的表是一样的。换句话来讲，分区对于应用是透明的，只是数据库对于数据的重新整理。

> https://segmentfault.com/a/1190000022780773
>
> https://www.jianshu.com/p/1cdd3e3c5b3c
>
> https://www.cnblogs.com/dw3306/p/12620042.html

### 87.表分区有什么好处?

- 与单个磁盘或文件系统分区相比，可以存储更多的数据。
- 对于那些已经失去保存意义的数据，通常可以通过删除与那些数据有关的分区，很容易地删除那些数据。相反地，在某些情况下，添加新数据的过程又可以通过为那些新数据专门增加一个新的分区，来很方便地实现。

### 88.表分区与分表的区别?

分表：指的是通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间成多个表。 分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。

### 89.MySQL支持的分区类型有哪些?

- RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区。
- LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择。
- HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。
- KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL 服务器提供其自身的哈希函数。必须有一列或多列包含整数值。

### 90.MySQL分区表有哪些限制因素?

1. 一个表最多只能有1024个分区（mysql5.6之后支持8192个分区）。
2. 在mysql5.1中分区表达式必须是整数，或者是返回整数的表达式，在5.5之后，某些场景可以直接使用字符串列和日期类型列来进行分区（使用varchar字符串类型列时，一般还是字符串的日期作为分区）。
3. 如果分区字段中有主键或者唯一索引列，那么所有主键列和唯一索引列都必须包含进来，如果表中有主键或唯一索引，那么分区键必须是主键或唯一索引。
4. 分区表中无法使用外键约束。
5. mysql数据库支持的分区类型为水平分区，并不支持垂直分区，因此，mysql数据库的分区中索引是局部分区索引，一个分区中既存放了数据又存放了索引，而全局分区是指的数据库放在各个分区中，但是所有的数据的索引放在另外一个对象中
6. 目前mysql不支持空间类型和临时表类型进行分区。不支持全文索引。

### 91.MySQL 为什么要分库分表?

数据库数据会随着业务的发展而不断增多，因此数据操作，如增删改查的开销也会越来越大。

再加上物理服务器的资源有限(CPU、磁盘、内存、IO 等)。最终数据库所能承载的数据量、数据处理能力都将遭遇瓶颈。

换句话说需要合理的数据库架构来存放不断增长的数据，这个就是分库分表的设计初衷。目的就是为了缓解数据库的压力，最大限度提高数据操作的效率。

### 92.MySQL 达到什么量需要分库分表?

阿里巴巴《Java 开发手册》提出单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表

### 93.MySQL 分库分表怎么做?

根据容量（当前容量和增长量）评估分库或分表个数 -> 选key（均匀）-> 分表规则（hash或range等）-> 执行（一般双写）-> 扩容问题（尽量减少数据的移动）。

### 94.MySQL分库分表工具有哪些?

1. sharding-sphere：jar，前身是sharding-jdbc；
2. TDDL：jar，Taobao Distribute Data Layer；
3. Mycat：[中间件](https://cloud.tencent.com/product/tdmq?from=10680)。

注：工具的利弊，请自行调研，官网和社区优先。

> https://cloud.tencent.com/developer/article/1623139

### 95.MySQL 分库分表会产生哪些问题?

（1）跨库关联查询

（2）分布式事务

（3）排序、分页、函数计算问题

（4）分布式 ID

（5）多数据源

> https://z.itpub.net/article/detail/23A4168E598B38BFFA57828C5C0D2E9C

### 96.MySQL批量插入，如何不插入重复数据?

ON DUPLICATE KEY UPDATE 

```java
<insert id="batchSaveUser" parameterType="list">
    insert into user (id,username,mobile_number)
    values
    <foreach collection="list" item="item" index="index" separator=",">
        (
            #{item.id},
            #{item.username},
            #{item.mobileNumber}
        )
    </foreach>
    ON duplicate KEY UPDATE id = id
</insert>
```

> https://segmentfault.com/a/1190000039912996

### 97.MySQL中为什么不建议使用 UTF-8?

### 98.MySQL为什么不建议用 UUID做主键?

### 99.MySQL提高并发可以调整哪些参数?

### 100.MySQL日期NOW和SYSDATE的区别?

mysql中日期函数NOW()和SYSDATE()都表示当前时间，NOW()取的是语句开始执行的时间，SYSDATE()取的是语句执行过程中动态的实时时间。

NOW()取自mysql的一个变量”TIMESTAMP”，这个变量在语句开始执行的时候就设定好了，因此在整个语句执行过程中都不会变化。

![image-20211007175145458](https://note-java.oss-cn-beijing.aliyuncs.com/img/image-20211007175145458.png)

> https://blog.csdn.net/mycms5/article/details/72763176

### 101.MySQL怎么查看当前数据库版本?

### 102.MySQL 常用的客户端有哪些?
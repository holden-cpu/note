## MySQL

### 1.主键、外键有什么区别?

主键：用来表示一条记录的唯一表示，不能有重复，不允许为空，默认为聚集索引，用来保证数据完整性。

外键：表的某列是另一表 的主键，外键可以重复，可以是空值，用来和其他表建立关联用的

### 2.什么是范式化?

范式化是指数据库设计的规范，通过使用不同层次的范式，达到在数据库设计中，减少数据冗余，增进数据一致性的目的。

### 3.什么是反范式化?

反范式化是指为了查询效率的考虑，把原来符合第三范式的表适当增加冗余，以达到优化查询效率的目的，反范式化是一种以空间换取时间的操作

### 4.三范式分别是指哪三个?

第一范式（1NF）: 列的原子性（同一列不能有多个值）

第二范式（2NF）:消除了非主属性对于码的部分函数依赖（满足1NF且非主键列都完全函数依赖于主键）

- 必须满足1NF
- 必须有一个主键，且没有包含在主键中的列必须完全依赖于主键，而不能只依赖主键的一部分

第三范式（3NF）:消除了非主属性对于码的传递函数依赖（满足2NF且非主属性列都不传递依赖于主键）

- 满足2NF
- 不能有传递的依赖关系。换句话说，表中的每一列和主键直接相关，不能是间接相关的。再换句话说，通过主键就能直接定位到每一列，而不能是间接才能定位到

BCNF:消除了主属性对于码的部分函数依赖和传递函数依赖（即满足3NF，并且主属性之间没有依赖关系）

- 满足3NF
- 主属性之间没有依赖关系。

### 5.范式化有什么优缺点?

优点：

- 范式化更新操作通常比反范式化要快。
- 当数据较好的范式化时，就只有很少或者没有重复数据，所以，只需要修改更少的数据。
- 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快。
- 很少有多余的数据意味着检索列表数据更少需要distinct或者group by 语句。

缺点：

- 范式化设计schema通常需要关联。稍微复杂一些的查询语句在符合范式的schema上都可能需要至少一次关联，也许更多。这样做代价昂贵，也可能使一些索引策略无效。例如，范式化可能将列放在不同的表中，而这些列在同一个表中可以数据同一个索引。

### 6.反范式化有什么优缺点?

优点：

- 所有数据都在一张表中，可以很好地避免关联。
- 如果不需要关联表，则对大部分查询最差情况——即没有使用索引——全表扫描。当数据币内存大时这可能比关联要快很多， 这样避免了随机I/O。
- 单独的表也能使用更有效的索引策略。

缺点：

- 表格内的冗余较多
- 删除数据时候会造成表有些有用的信息丢失

### 7.数据库设计时怎么使用范式?

在真实环境中很少会极端地使用范式化或者反范式化的schema。而是可能使用部分范式化的schema、缓存表、以及其它技巧。最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定的列。在Mysql5.0和更新版本中，可以使用触发器更新缓存值，这使得实现这样的方案变得更简单。

### 8.什么是事务?

事务就是一组原子性的 SQL 查询，或者说是一个独立的工作单元。如果数据库引擎能够成功地队数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。

### 9.事务有哪几个特性?

原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的操作要么都做，要么都不做。

一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。

隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

持久性（durability）。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系:

- 只有满足一致性，事务的执行结果才是正确的。
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久化是为了能应对数据库崩溃的情况。

### 10.什么是脏读、幻读、不可重复读?

脏读（Dirty Read）：一个事务可以读取另一个事务未提交的数据。

不可重复读：事务 T1 读到某行；事务 T2 修改或删除这行，提交事务；T1 重新读取发现这行数据已经被修改或删除。

幻读：事务 T1 读取了 N 行；事务 T2 在事务 T1 读取的条件范围内生成了一行或多行数据；T1 重新读取获得与之前不同集合的行数据。（InnoDB 和 XtraDB 存储引擎通过多版本并发控制）解决了幻读的问题

### 11.MySQL有哪些事务隔离级别?

- 读未提交（Read Uncommitted）：是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。会出现脏读，幻读，不可重复读，所有并发问题都可能遇到。该隔离级别可以通过“排他写锁”实现，即事物需要对某些数据进行修改必须对这些数据加+X+锁，读数据不需要加+S+锁。
- 读已提交（Read Committed）：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。不会出现脏读现象，但是会出现幻读，不可重复读。这可以通过“瞬间共享读锁”和“排他写锁”实现， 即事物需要对某些数据进行修改必须对这些数据加 X 锁，读数据时需要加上 S 锁，当数据读取完成后立刻释放 S 锁，不用等到事物结束。
- 可重复读（Repeatable Read）：这种事务隔离级别保证了同一事务中多次读取同样记录的结果是一致的，可以防止脏读，不可重复读，但是可能会出现幻读。这可以通过“共享读锁”和“排他写锁”实现，即事物需要对某些数据进行修改必须对这些数据加 X 锁，读数据时需要加上 S 锁，当数据读取完成并不立刻释放 S 锁，而是等到事物结束后再释放。
- 串行化（Serializable）：Serializable会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。防止脏读、不可重复读、幻象读。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| ---------------------------- | ---- | ---------- | ---- | ------ |
| 读未提交（read-uncommitted） | 是   | 是         | 是   | 否     |
| 不可重复读（read-committed） | 否   | 是         | 是   | 否     |
| 可重复读（repeatable-read）  | 否   | 否         | 是   | 否     |
| 串行化（serializable）       | 否   | 否         | 否   | 是     |

### 12.MySQL默认的事务隔离级别是?

可重复读

### 13.MySQL事务默认提交模式是?

可重复读

### 14.MySQL事务如何开启、禁用自动提交?

直接用 SET 来改变提交模式:

- SET AUTOCOMMIT=0 禁止自动提交
- SET AUTOCOMMIT=1 开启自动提交

### 15.MySQL中哪些存储引擎支持事务?

在mysql中用的最多的存储引擎有：innodb，bdb，myisam ,memory 等。其中innodb和bdb支持事务而myisam等不支持事务。

### 16.MySQL 切换数据库用什么命令?

show databases; 显示所有已经存在的数据库

create database test； 创建名字为test的数据库

drop database test； 删除名字为test的数据库

use test；使用名字为test的数据库

### 17.MySQL 查看所有数据库用什么命令?

show databases;

### 18.MySQL 查看当前库所有表用什么命令?

show tables； 显示这个数据库中的所有数据表

describe player; 显示player这张表的属性

### 19.什么是索引?

MySQL官方对索引的定义为：**索引（INDEX）是帮助MySQL高效获取数据的数据结果。**

从而可以获得索引的本质：**索引是排好序的快速查找数据结构。**

### 20.索引有什么用?

索引的目的在于提高查询效率，可以类比字典的目录

### 21.索引为什么能提高查询效率?

索引就是通过事先排好序，从而在查找时可以应用二分查找等高效率的算法。

一般的顺序查找，复杂度为O(n)，而二分查找复杂度为O(log2n)。当n很大时，二者的效率相差及其悬殊。

### 22.索引的设计有哪些原则?

1. 选择唯一性索引

   唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。

2. 为经常需要排序、分组和联合操作的字段建立索引

   经常需要 ORDER BY、GROUP BY、DISTINCT 和 UNION 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。

3. 为常作为查询条件的字段建立索引

   如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。

   注意：常查询条件的字段不一定是所要选择的列，换句话说，最适合索引的列是出现在 WHERE 子句中的列，或连接子句中指定的列，而不是出现在 SELECT 关键字后的选择列表中的列。

4. 限制索引的数目

   索引的数目不是“越多越好”。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。在修改表的内容时，索引必须进行更新，有时还可能需要重构。因此，索引越多，更新表的时间就越长。

   如果有一个索引很少利用或从不使用，那么会不必要地减缓表的修改速度。此外，MySQL 在生成一个执行计划时，要考虑各个索引，这也要花费时间。创建多余的索引给查询优化带来了更多的工作。索引太多，也可能会使 MySQL 选择不到所要使用的最佳索引。

5. 尽量使用数据量少的索引

   如果索引的值很长，那么查询的速度会受到影响。例如，对一个 CHAR(100) 类型的字段进行全文检索需要的时间肯定要比对 CHAR(10) 类型的字段需要的时间要多。

6. 数据量小的表最好不要使用索引

   由于数据较小，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。

7. 尽量使用前缀来索引

   如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。

8. 删除不再使用或者很少使用的索引

   表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。应该定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。

### 23.索引对数据库有什么负面影响?

- 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的。
- 虽然索引大大提高了查询速度，但是同时会降低表的更新速度，例如对表频繁的进行`INSERT`、`UPDATE`和`DELETE`。因为更新表的时候，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加的索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。
- 索引只是提高效率的一个因素，如果MySQL有大数据量的表，就需要花时间研究建立最优秀的索引。

### 24.什么情况下应不建或少建索引?

- 记录太少的表。
- 经常增删改的表。
- 频繁更新的字段不适合创建索引。
- Where条件里用不到的字段不创建索引。
- 数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。
  - 假如一个表有10万行记录，有一个字段A只有true和false两种值，并且每个值的分布概率大约为50%，那么对A字段建索引一般不会提高数据库的查询速度。
  - 索引的选择性是指索引列中不同值的数目与表中记录数的比。如果一个表中有2000条记录，表索引列有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，这个索引的效率就越高。

### 25.MySQL 索引的种类有哪些?

按数据结构分类可分为：B+tree索引、Hash索引、Full-text索引。
按物理存储分类可分为：聚簇索引、二级索引（辅助索引）。
按字段特性分类可分为：主键索引、普通索引、前缀索引。
按字段个数分类可分为：单列索引、联合索引（复合索引、组合索引）。

> https://segmentfault.com/a/1190000037683781

### 26.MySQL 索引命名有什么规范?

主键索引名为 pk字段名； 唯一索引名为 uk字段名； 普通索引名则为 idx_字段名 。

说明： pk_ 即 primary key； uk_ 即 unique key

### 27.MySQL 二级索引是什么?

二级索引：叶子节点中存储主键值，每次查找数据时，根据索引找到叶子节点中的主键值，根据主键值再到聚簇索引中得到完整的一行记录。

### 28.MySQL有了聚簇索引为啥还要二级索引?

聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。

聚簇索引的叶子节点存储了一行完整的数据，而二级索引只存储了主键值，相比于聚簇索引，占用的空间要少。当我们需要为表建立多个索引时，如果都是聚簇索引，那将占用大量内存空间，所以InnoDB中主键所建立的是聚簇索引，而唯一索引、普通索引、前缀索引等都是二级索引。

### 29.MySQL 索引最左匹配原则怎么理解?

最佳左前缀法则：如果索引是多字段的复合索引，要遵守最佳左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的字段。

MySQL 建立联合索引的规则是这样的，它会首先根据联合索引中最左边的、也就是第一个字段进行排序，在第一个字段排序的基础上，再对联合索引中后面的第二个字段进行排序，依此类推。

综上，第一个字段是绝对有序的，从第二个字段开始是无序的，这就解释了为什么直接使用第二字段进行条件判断用不到索引了（从第二个字段开始，无序，无法走 B+ Tree 索引）！这也是 MySQL 在联合索引中强调最左前缀匹配原则的原因。

> https://blog.csdn.net/u013568373/article/details/93891531

### 30.MySQL 中的隐藏索引是什么?

MySQL支持隐藏索引，即在不改变实际索引结构的情况下，优化器不使用该索引。这个特性可以使用在任何非主键上。

> https://www.jianshu.com/p/eac8872e50a9

### 31.MySQL 索引实现是什么数据结构?

B+树

### 32.MySQL一个表最多创建多少个索引?

索引个数没有限制

一个表最多可以包含64个二级索引。对于多列索引，最多允许16列。超过限制将返回错误。

### 33.MySQL 索引最多包含多少个列?

16

### 34.MySQL索引为什么选用 B+Tree?

> https://www.cnblogs.com/liqiangchn/p/12995831.html

https://blog.csdn.net/zhuanzhe117/article/details/78039692

B+Tree是在B-Tree基础上演进而来的。与之不同的是B+Tree的数据页只存储在叶子节点中，并且叶子节点之间通过指针相连，为双向链表结构。

1. 充分利用空间局部性原理，适合磁盘存储。
2. 树的高度很低，能够在存储大量数据情况下，进行较少的磁盘IO【见下文介绍】。
3. 能够很好支持单值，范围查询，有序性查询。
4. 索引和数据分开存储，让更多的索引存储在内存中。

### 35.MySQL B+ 树索引和哈希索引的区别?

- 如果是<font color='red'>等值查询，那么哈希索引明显有绝对优势</font>，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；
- 从示意图中也能看到，<font color='red'>如果是范围查询检索，这时候哈希索引就毫无用武之地了</font>，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；
- 同理，<font color='red'>哈希索引也没办法利用索引完成排</font>序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；
- <font color='red'>哈希索引也不支持多列联合索引的最左匹配规则；</font>
- B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，<font color='red'>在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。</font>

在MySQL中，只有HEAP/MEMORY引擎表才能显式支持哈希索引（NDB也支持，但这个不常用），InnoDB引擎的自适应哈希索引（adaptive hash index）不在此列，因为这不是创建索引时可指定的。
还需要注意到：HEAP/MEMORY引擎表在mysql实例重启后，数据会丢失。

### 36.MySQL B+树的一个节点为多大?

1页，16k

首先InnoDB的B+树中，非叶子节点存的是key + 指针；叶子节点存的是数据行。
对于叶子节点，如果一行数据大小为1k，那么一页就能存16条数据；对于非叶子节点，如果key使用的是bigint，则为8字节，指针在mysql中为6字节，一共是14字节，则16k能存放 16 * 1024 / 14 = 1170 个索引指针。于是可以算出，对于一颗高度为2的B+树，根节点存储索引指针节点，那么它有1170个叶子节点存储数据，每个叶子节点可以存储16条数据，一共 1170 x 16 = 18720 条数据。而对于高度为3的B+树，就可以存放 1170 x 1170 x 16 = 21902400 条数据（两千多万条数据），也就是对于两千多万条的数据，我们只需要高度为3的B+树就可以完成，通过主键查询只需要3次IO操作就能查到对应数据。所以在 InnoDB 中B+树高度一般为3层时，就能满足千万级的数据存储，所以一个节点为1页，也就是16k是比较合理的

### 37.MySQL 索引在哪些情况下会失效?

- 条件中带有以通配符%开头的 like
-  当使用or关键字时，or语句前后没有同时使用索引，该索引失效，只有当or左右查询字段均为索引时，才会生效。
- 在索引字段上使用函数、计算、类型转换
- 在索引字段上使用not及运算符
- 使用`!=`或者`<>`
- `is null`、`is not null`也无法使用索引
- 字符串不加单引号索引失效。
- 使用组合索引时，如果查询条件不包括该组合索引全部字段或查询条件不是该组合索引左边第一个字段时，索引失效。(最左匹配)
- 全表扫描的速度大于索引速度时，索引失效。如表内数据极少

### 38.MySQL 默认最大的连接数是多少?

> https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_max_connections

[`max_connections`](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_max_connections)

| Command-Line Format                                          | `--max-connections=#` |
| :----------------------------------------------------------- | --------------------- |
| System Variable                                              | `max_connections`     |
| Scope                                                        | Global                |
| Dynamic                                                      | Yes                   |
| [`SET_VAR`](https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-set-var) Hint Applies | No                    |
| Type                                                         | Integer               |
| Default Value                                                | `151`                 |
| Minimum Value                                                | `1`                   |
| Maximum Value                                                | `100000`              |

### 39.MySQL数据库引擎怎么选择?

| 特性         | MyISAM | InnoDB | MEMORY |
| ------------ | ------ | ------ | ------ |
| 存储限制     | 有     | 支持   | 有     |
| 事务安全     | 不支持 | 支持   | 不支持 |
| 锁机制       | 表锁   | 行锁   | 表锁   |
| B树索引      | 支持   | 支持   | 支持   |
| 哈希索引     | 不支持 | 不支持 | 支持   |
| 全文索引     | 支持   | 不支持 | 不支持 |
| 集群索引     | 不支持 | 支持   | 不支持 |
| 数据缓存     |        | 支持   | 支持   |
| 索引缓存     | 支持   | 支持   | 支持   |
| 数据可压缩   | 支持   | 不支持 | 不支持 |
| 空间使用     | 低     | 高     | N/A    |
| 内存使用     | 低     | 高     | 中等   |
| 批量插入速度 | 高     | 低     | 高     |
| 支持外键     | 不支持 | 支持   | 不支持 |

1) MyISAM

在 MySQL 5.1 版本及之前的版本，MyISAM 是默认的存储引擎。
MyISAM 存储引擎不支持事务和外键，所以访问速度比较快。如果应用主要以读取和写入为主，只有少量的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择 MyISAM 存储引擎是非常适合的。
MyISAM 是在 Web 数据仓储和其他应用环境下最常使用的存储引擎之一。

2) InnoDB

MySQL 5.5 版本之后默认的事务型引擎修改为 InnoDB。
InnoDB 存储引擎在事务上具有优势，即支持具有提交、回滚和崩溃恢复能力的事务安装，所以比 MyISAM 存储引擎占用更多的磁盘空间。

如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包括很多的更新、删除操作，那么 InnoDB 存储引擎是比较合适的选择。
InnoDB 存储引擎除了可以有效地降低由于删除和更新导致的锁定，还可以确保事务的完整提交（Commit）和回滚（Rollback），对于类似计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB 都是合适的选择。

 3) MEMORY

MEMORY 存储引擎将所有数据保存在 RAM 中，所以该存储引擎的数据访问速度快，但是安全上没有保障。

MEMORY 对表的大小有限制，太大的表无法缓存在内存中。由于使用 MEMORY 存储引擎没有安全保障，所以要确保数据库异常终止后表中的数据可以恢复。

如果应用中涉及数据比较少，且需要进行快速访问，则适合使用 MEMORY 存储引擎。

### 40.MySQL 默认数据库引擎是什么?

InnoDB

### 41.MySQL引擎MyISAM和 InnoDB的区别?

**MyISAM：**

每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义，数据文件的扩展名为.MYD (MYData)，索引文件的扩展名是.MYI (MYIndex)。

MyISAM表格可以被压缩，而且它们支持全文搜索。不支持事务，而且也不支持外键。如果事物回滚将造成不完全回滚，不具有原子性。在进行updata时进行表锁，并发量相对较小。如果执行大量的SELECT，MyISAM是更好的选择。

MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小

MyISAM缓存在内存的是索引，不是数据。而InnoDB缓存在内存的是数据，相对来说，服务器内存越大，InnoDB发挥的优势越大。

**优点：**查询数据相对较快，适合大量的select，可以全文索引。

**缺点：**不支持事务，不支持外键，并发量较小，不适合大量update

**InnoDB：**

这种类型是事务安全的。它与BDB类型具有相同的特性,它们还支持外键。InnoDB表格速度很快。具有比BDB还丰富的特性,因此如果需要一个事务安全的存储引擎，建议使用它。在update时表进行行锁，并发量相对较大。如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。

**优点：**支持事务，支持外键，并发量较大，适合大量update

**缺点：**查询数据相对较快，不适合大量的select

对于支持事物的InnoDB类型的表，影响速度的主要原因是AUTOCOMMIT默认设置是打开的，而且程序没有显式调用BEGIN 开始事务，导致每插入一条都自动Commit，严重影响了速度。可以在执行sql前调用begin，多条sql形成一个事物（即使autocommit打开也可以），将大大提高性能。

**基本的差别为**：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。

MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持已经外部键等高级数据库功能。

### 42.MySQL InnoDB引擎的物理存储文件?

.frm文件

.ibd文件和.ibdata文件：

这两种文件都是存放innodb数据的文件，之所以用两种文件来存放innodb的数据，是因为innodb的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据。

独享表空间存储方式使用.ibd文件，并且每个表一个ibd文件

共享表空间存储方式使用.ibdata文件，所有表共同使用一个ibdata文件

> https://blog.csdn.net/qq_42112448/article/details/105270081
>
> https://baijiahao.baidu.com/s?id=1660374685951447632&wfr=spider&for=pc

### 43.MySQL MyISAM引擎的物理存储文件?

（1）frm文件：存储表的定义数据

（2）MYD文件：存放表具体记录的数据

（3）MYI文件：存储索引

frm和MYI可以存放在不同的目录下。MYI文件用来存储索引，但仅保存记录所在页的指针，索引的结构是B+树结构。

### 44.char和 varchar 的区别?

- char 是一种固定长度的字符串类型
- varchar 是一种可变长度的字符串类型

### 45.常用的 SQL JOIN 连接及区别?

![七种JOIN理论](https://note-java.oss-cn-beijing.aliyuncs.com/img/20200801212011559.jpg)

### 46.SQL 中的笛卡尔积是什么?

笛卡尔积，又叫cross join，是SQL中两表连接的一种方式。
假如A表中的数据为m行，B表中的数据有n行，那么A和B做笛卡尔积，结果为m*n行。

### 47.如何避免 SQL 出现笛卡尔积?

两表关联的时候通过最小的粒度关联（唯一字段）

### 48.union和 union all的区别?

union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序（根据主键升序排序）；

union all: 对两个结果集进行并集操作, 包括重复行, 即所有的结果全部显示, 不管是不是重复。

### 49.为什么不建议用 union而用 union all?

union all只是合并查询结果，并不会进行去重和排序操作，在没有去重的前提下，使用union all的执行效率要比union高

### 50.MySQL的drop、delete、truncate区别?

- drop (删除表)：删除内容和定义，释放空间，简单来说就是**把整个表去掉**，以后要新增数据是不可能的，除非新增一个表。

  drop语句将删除表的结构被依赖的约束（constrain），触发器（trigger）索引（index），依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。

  如果要删除表定义及其数据，请使用 drop table 语句。

- truncate (清空表中的数据)：删除内容、释放空间但不删除定义(**保留表的数据结构**)，与drop不同的是，只是清空表数据而已。

  注意：truncate不能删除具体行数据，要删就要把整个表清空了。

- delete (删除表中的数据)：delete 语句用于**删除表中的行**。delete语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存，以便进行进行回滚操作。

  truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）

  truncate table 删除表中的所有行，但表结构及其列、约束、索引等保持不变。

  对于由foreign key约束引用的表，不能使用truncate table ，而应使用不带where子句的delete语句。由于truncate table 记录在日志中，所以它不能激活触发器。

  delete语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，**事务提交之后才生效**；如果有相应的 trigger，执行的时候将被触发。

  **truncate、drop 是数据库定义语言(ddl)，操作立即生效**，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。

  **如果有自增列，truncate方式删除之后，自增列的值会被初始化，delete方式要分情况（如果数据库被重启了，自增列值也会被初始化，数据库未被重启，则不变）**

- **如果要删除表定义及其数据，请使用 drop table 语句**

- **安全性：小心使用 drop 和 truncate，尤其没有备份的时候，否则哭都来不及**

- **删除速度，一般来说: drop> truncate > delete**

### 51.MySQL怎么实现分页查询?

```sql
select * from table limit (pageNo-1)*pageSize, pageSize;
```

### 52.MySQL的高可用方案有哪些?

https://zhuanlan.zhihu.com/p/25960208

### 53.如何分析一条 SQL 语句的执行计划和性能?

explain sql语句

### 54.MySQL 查询优化有哪些方法?

https://segmentfault.com/a/1190000011330649

**避免向数据库请求不需要的数据**

在访问数据库时，应该只请求需要的行和列。请求多余的行和列会消耗MySql服务器的CPU和内存资源，并增加网络开销。
例如在处理分页时，应该使用LIMIT限制MySql只返回一页的数据，而不是向应用程序返回全部数据后，再由应用程序过滤不需要的行。
当一行数据被多次使用时可以考虑将数据行缓存起来，避免每次使用都要到MySql查询。
避免使用SELECT *这种方式进行查询，应该只返回需要的列。

**查询数据的方式**

查询数据的方式有全表扫描、索引扫描、范围扫描、唯一索引查询、常数引用等。这些查询方式，速度从慢到快，扫描的行数也是从多到少。可以通过EXPLAIN语句中的type列反应查询采用的是哪种方式。
通常可以通过添加合适的索引改善查询数据的方式，使其尽可能减少扫描的数据行，加快查询速度。
例如，当发现查询需要扫描大量的数据行但只返回少数的行，那么可以考虑使用覆盖索引，即把所有需要用到的列都放到索引中。这样存储引擎无须回表获取对应行就可以返回结果了。

**分解大的查询**

可以将一个大查询切分成多个小查询执行，每个小查询只完成整个查询任务的一小部分，每次只返回一小部分结果
删除旧的数据是一个很好的例子。如果只用一条语句一次性执行一个大的删除操作，则可能需要一次锁住很多数据，占满整个事务日志，耗尽系统资源、阻塞很多小的但重要的查询。将一个大的删除操作分解成多个较小的删除操作可以将服务器上原本一次性的压力分散到多次操作上，尽可能小地影响MySql性能，减少删除时锁的等待时间。同时也减少了MySql主从复制的延迟。
另一个例子是分解关联查询，即对每个要关联的表进行单表查询，然后将结果在应用程序中进行关联。下面的这个查询：

```lasso
SELECT * FROM tag
    JOIN tag_post ON tag_post.tag_id=tag.id
    JOIN post ON tag_post.post_id=post.id
WHERE tag.tag = 'mysql';
```

可以分解成下面这些查询来代替：

```n1ql
SELECT * FROM tag WHERE tag = 'mysql';
SELECT * FROM tag_post WHERE tag_id = 1234;
SELECT * FROM post WHERE post.id in (123,456,567,9098,8904);
```

将一个关联查询拆解成多个单表查询有如下有点：

1. 让缓存的效率更高。如果缓存的是关联查询的结果，那么其中的一个表发生变化，整个缓存就失效了。而拆分后，如果只是某个表很少的改动，并不会破坏所有的缓存。
2. 可以减少锁的竞争
3. 更容易对数据库进行拆分，更容易做到高性能和可扩展。
4. 查询本身的效率也有可能会有所提升。例如上面用IN()代替关联查询比随机的关联更加高效。

**优化MIN()和MAX()**

添加索引可以优化MIN()和MAX()表达式。例如，要找到某一列的最小值，只需要查询对应B-Tree索引的最左端的记录即可。类似的，如果要查询列中的最大值，也只需要读取B-Tree索引的最后一条记录。对于这种查询，EXPLAIN中可以看到"Select tables optimized away",表示优化器已经从执行计划中移除了该表，并以一个常数取而代之。

**用IN()取代OR**

在MySql中，IN()先将自己列表中的数据进行排序，然后通过二分查找的方式确定列的值是否在IN()的列表中，这个时间复杂度是O(logn)。如果换成OR操作，则时间复杂度是O(n)。所以，对于IN()的列表中有大量取值的时候，用IN()替换OR操作将会更快。

**优化关联查询**

在MySql中，任何一个查询都可以看成是一个关联查询，即使只有一个表的查询也是如此。
MySql对任何关联都执行嵌套循环的关联操作，例如对于下面的SQL语句：

```sql
SELECT tbl1.col1,tbl2.col2
FROM tbl1 INNER JOIN tbl2 USING(col3)
WHERE tbl1.col1 IN(5,6);
```

下面的伪代码表示MySql将如何执行这个查询：

```awk
//先从第一个表中取出符合条件的所有行
out_iter = iterator over tbl1 where col1 IN(5,6)
outer_row = out_iter.next
//在while循环中遍历第一个表结果集的每一行
while outer_row
    //对于第一个表结果集中的每一行，在第二个表中找出符合条件的所有行
    inner_iter = iterator over tbl2 where col3 = outer_row.col3
    inner_row = inner_iter.next
    while inner_row
        //将第一个表的结果列和第二个表的结果列拼装在一起作为结果输出
        output[outer_row.col1, inner_row.col2]
        inner_row = inner_iter.next
    end
    //回溯，再根据第一个表结果集的下一行，继续上面的过程
    outer_row = outer_iter.next
end
```

对于单表查询，那么只需要完成上面外层的基本操作。
优化关联查询，要确保ON或者USING子句中的列上有索引，并且在建立索引时需要考虑到关联的顺序。通常来说，只需要在关联顺序中的第二个表的相应列上创建索引。例如，当表A和表B用列c关联的时候，假设关联的顺序是B、A，那么就不需要在B表的c列上建立索引。没有用到的索引只会带来额外的负担。
此外，确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，这样才能使用索引来优化这个过程。

**临时表的概念**

上面提到在MySql中，任何一个查询实质上都是一个关联查询。那么对于子查询或UNION查询是如何实现关联操作的呢。
对于UNION查询，MySql先将每一个单表查询结果放到一个临时表中，然后再重新读出临时表数据来完成UNION查询。MySql读取结果临时表和普通表一样，也是采用的关联方式。
当遇到子查询时，先执行子查询并将结果放到一个临时表中，然后再将这个临时表当做一个普通表对待。
MySql的临时表是没有任何索引的，在编写复杂的子查询和关联查询的时候需要注意这一点。
临时表也叫派生表。

**排序优化**

应该尽量让MySql使用索引进行排序。当不能使用索引生成排序结果的时候，MySql需要自己进行排序。如果数据量小于“排序缓冲区”的大小，则MySql使用内存进行“快速排序”操作。如果数据量太大超过“排序缓冲区”的大小，那么MySql只能采用文件排序，而文件排序的算法非常复杂，会消耗很多资源。
无论如何排序都是一个成本很高的操作，所以从性能角度考虑，应尽可能避免排序。所以让MySql根据索引构造排序结果非常的重要。

**子查询优化**

MySql的子查询实现的非常糟糕。最糟糕的一类查询是WHERE条件中包含IN()的子查询语句。
应该尽可能用关联替换子查询，可以提高查询效率。

**优化COUNT()查询**

COUNT()有两个不同的作用：

1. 统计某个列值的数量，即统计某列值不为NULL的个数。
2. 统计行数。

当使用COUNT(*)时，统计的是行数，它会忽略所有的列而直接统计所有的行数。而在括号中指定了一个列的话，则统计的是这个列上值不为NULL的个数。
可以考虑使用索引覆盖扫描或增加汇总表对COUNT()进行优化。

**优化LIMIT分页**

处理分页会使用到LIMIT，当翻页到非常靠后的页面的时候，偏移量会非常大，这时LIMIT的效率会非常差。例如对于***LIMIT 10000，20\***这样的查询，MySql需要查询10020条记录，将前面10000条记录抛弃，只返回最后的20条。这样的代价非常高，如果所有的页面被访问的频率都相同，那么这样的查询平均需要访问半个表的数据。
优化此类分页查询的一个最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列。然后根据需要与原表做一次关联操作返回所需的列。对于偏移量很大的时候，这样的效率会提升非常大。考虑下面的查询：

```n1ql
SELECT film_id, description FROM sakila.film ORDER BY title LIMIT 50, 5;
```

如果这个表非常大，那么这个查询最好改写成下面的这样子：

```n1ql
SELECT film.film_id, film.description FROM sakila.film
INNER JOIN 
(SELECT film_id FROM sakila.film ORDER BY title LIMIT 50,5) AS lim
USING(film_id);
```

注意优化中关联的子查询，因为只查询film_id一个列，数据量小，使得一个内存页可以容纳更多的数据，这让MySQL扫描尽可能少的页面。在获取到所需要的所有行之后再与原表进行关联以获得需要的全部列。
LIMIT的优化问题，其实是OFFSET的问题，它会导致MySql扫描大量不需要的行然后再抛弃掉。可以借助书签的思想记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就避免了使用OFFSET。可以把主键当做书签使用，例如下面的查询：

```n1ql
SELECT * FROM sakila.rental ORDER BY rental_id DESC LIMIT 20;
```

假设上面的查询返回的是主键为16049到16030的租借记录，那么下一页查询就可以直接从16030这个点开始：

```n1ql
SELECT * FROM sakila.rental WHERE rental_id < 16030
ORDER BY rental_id DESC LIMIT 20;
```

该技术的好处是无论翻页到多么后面，其性能都会很好。
此外，也可以用关联到一个冗余表的方式提高LIMIT的性能，冗余表只包含主键列和需要做排序的数据列。

**优化UNION查询**

除非确实需要服务器消除重复的行，否则一定要使用UNION ALL。如果没有ALL关键字，MySql会给临时表加上DISTINCT选项，这会导致对整个临时表的数据做唯一性检查。这样做的代价非常高。

### 55.MySQL为什么不建议默认 nul值?

1. NULL作为布尔值的时候，不为1也不为0

2. 任何值和NULL使用运算符（>、<、>=、<=、!=、<>）或者（in、not in、any/some、all），返回值都为NULL

3. 当IN和NULL比较时，无法查询出为NULL的记录

4. 当NOT IN 后面有NULL值时，不论什么情况下，整个sql的查询结果都为空

5. 判断是否为空只能用IS NULL、IS NOT NULL

6. count(字段)无法统计字段为NULL的值，count(\*)可以统计值为null的行

7. 当字段为主键的时候，字段会自动设置为not null

8. NULL导致的坑让人防不胜防，强烈建议创建字段的时候字段不允许为NULL，给个默认值

9. MySQL 中存在 NULL 值的列也是走索引的

   如果查询中包含null，对mysql来说更难优化，因为可为null的列使得索引，索引统计和值比较都更复杂。可为null的列会使用更多的存储空间，在mysql里也需要特殊处理。当可为null的列被索引时，每个索引记录需要一个额外的字节。
   如果在计划列上建立索引，就应该尽量避免设计成可为null的列

### 56.MySQL为什么尽量选择最小数据类型?

更小的数据类型通常更快，耗用更少的cpu，磁盘。

### 57.MySQL模糊查询会导致索引失效吗?

使用like关键字模糊查询时，% 放在前面索引不起作用，只有“%”不在第一个位置，索引才会生效（like ‘%文’–索引不起作用）

### 58.MySQL模糊查询怎么只匹配一个字符?

`like '_'`

### 59.MySQL 模糊查询怎么匹配多个字符?

`like '%'`

### 60.MySQL怎么记录慢查询语句?

https://www.cnblogs.com/kerrycode/p/5593204.html

### 61.MySQL支持查询结果缓存吗?

MySQL 4.0推出，5.6中默认禁用，5.7中被deprecated（废弃），8.0版本被Removed，

> https://segmentfault.com/a/1190000038554542

### 62.怎么理解数据库中的乐观锁?

乐观锁（ Optimistic Locking ） 是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。

相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是CAS和记录数据版本解决ABA问题。

> https://www.cnblogs.com/kyoner/p/11318979.html

### 63.怎么理解数据库中的悲观锁?

当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。

这种借助数据库锁机制在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。

之所以叫做悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式。我们一般认为数据被并发修改的概率比较大，所以需要在修改之前先加锁。

悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。

### 64.MySQL中的for update 锁的是什么?

用法： select … for update;

例如：select * from goods where id = 1 for update;

排他锁的申请前提：没有线程对该结果集中的任何行数据使用排他锁或共享锁，否则申请会阻塞。

for update仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。

**当前读**就是读取最新数据，而不是历史版本的数据。加锁的 SELECT 就属于当前读，例如：

```sql
SELECT * FROM t WHERE id=1 LOCK IN SHARE MODE;
SELECT * FROM t WHERE id=1 FOR UPDATE;
```

> https://blog.csdn.net/claram/article/details/54023216

### 65.MySQL中的 MVCC 是指什么?

**多版本并发控制**技术的英文全称是 **Multiversion Concurrency Control**，简称 **MVCC**。

**多版本并发控制（MVCC）** 是通过保存数据在某个时间点的快照来实现并发控制的。也就是说，不管事务执行多长时间，事务内部看到的数据是不受其它事务影响的，根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

> https://segmentfault.com/a/1190000037557620

**多版本并发控制解决了哪些问题**

1. 读写之间阻塞的问题

通过 MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。

> 提高并发的演进思路：
>
> - 普通锁，只能串行执行；
> - 读写锁，可以实现读读并发；
> - 数据多版本并发控制，可以实现读写并发。

2. 降低了死锁的概率

因为 InnoDB 的 MVCC 采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。

3. 解决一致性读的问题

一致性读也被称为**快照读**，当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。

### 66.MySQL InnoDB的 MVCC 实现机制?

InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。一个保存了行的事务ID（DB_TRX_ID），一个保存了行的回滚指针（DB_ROLL_PTR）。每开始一个新的事务，都会自动递增产生一个新的事务id。事务开始时刻的会把事务id放到当前事务影响的行事务id中，当查询时需要用当前事务id和每行记录的事务id进行比较。

### 67.MySQL中的 MVCC支持的隔离级别?

多版本并发控制（MVCC） 在一定程度上实现了读写并发，它只在可重复读（REPEATABLE READ） 和 提交读（READ COMMITTED） 两个隔离级别下工作。其他两个隔离级别都和 MVCC 不兼容，因为 未提交读（READ UNCOMMITTED），总是读取最新的数据行，而不是符合当前事务版本的数据行。而 可串行化（SERIALIZABLE） 则会对所有读取的行都加锁。

### 68.MySQL支持哪三种级别的锁?

在关系型数据库中，可以按照锁的粒度把数据库锁分为**行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )**。

MySQL锁可以按模式分类为：乐观锁与悲观锁。按粒度分可以分为全局锁、表级锁、页级锁、行级锁。按属性可以分为：共享锁、排它锁。按状态分为：意向共享锁、意向排它锁。按算法分为：间隙锁、临键锁、记录锁。

### 69.MySQL InnoDB支持什么锁?

MyISAM采用表级锁(table-level locking)。

InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁

### 70.MySQL中的表锁有哪些?

> https://www.cnblogs.com/xiaolincoding/p/15146872.html

1. 元数据锁（MDL）;
2. 意向锁；
3. AUTO-INC 锁；

### 71.MySQL 中的行锁有哪些?

共享锁、排他锁

### 72.MySQL中的意向锁有什么用?

意向锁的目的是为了快速判断表里是否有记录被加锁。

> https://juejin.cn/post/6844903666332368909

### 73.MySQL 中的意向锁的分类?

- 意向共享锁

  （intention shared lock, IS）：事务有意向对表中的某些行加

  共享锁

  （S锁）

  ```
  -- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。
  SELECT column FROM table ... LOCK IN SHARE MODE;
  ```
  
- 意向排他锁

  （intention exclusive lock, IX）：事务有意向对表中的某些行加

  排他锁

  （X锁）

  ```
  -- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。
  SELECT column FROM table ... FOR UPDATE;
  ```

即：``意向锁是有数据引擎自己维护的，用户无法手动操作意向锁``，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。

### 74.MySQL中的意向锁是表锁还是行锁?

不与行锁互斥的表锁

### 75.MySQL中的自增锁有什么用?

在为某个字段声明 `AUTO_INCREMENT` 属性时，之后可以在插入数据时，可以不指定该字段的值，数据库会自动给该字段赋值递增的值，这主要是通过 AUTO-INC 锁实现的。

AUTO-INC 锁是特殊的表锁机制，锁**不是再一个事务提交后才释放，而是在执行完插入语句后就会立即释放**。

> https://www.cnblogs.com/xiaolincoding/p/15146872.html

### 76.MySQL行锁是锁的是什么?

MySQL的行锁是通过索引加载的，也就是说，行锁是加在索引响应的行上的，要是对应的SQL语句没有走索引，则会全表扫描，行锁则无法实现，取而代之的是表锁，此时其它事务无法对当前表进行更新或插入操作。

### 77.MySQL行锁实现的几种算法?

- Record Lock: 单个记录上的锁
- Gap Lock: 间隙锁，锁定一个范围，但不包括记录本上
- Next-Key Lock: Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身

> https://juejin.cn/post/6844904090594443278
>
> https://juejin.cn/post/6844903735500472333

### 78.MySQL什么情况会发生死锁?

两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。

> https://blog.csdn.net/qq_35549286/article/details/108831923

### 79.MySQL产生死锁有哪些必要条件?

（1） 互斥条件：一个资源每次只能被一个进程使用。 
（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 
（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 
（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 
这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 

### 80.MySQL死锁怎么排查?

### 81.MySQL 如何解决死锁?

1. 检查到死锁的循环依赖时，立即返回一个错误
2. 当查询的时间达到锁等待超时的设定后放弃锁请求
3. 将持有最少行级排他锁的事务进行回滚

死锁检测的原理是构建一个以事务为顶点、锁为边的有向图，判断有向图是否存在环，存在即有死锁。

### 82.MySQL 如何避免死锁?

在程序中，操作多张表时，尽量以相同的顺序来访问（避免形成等待环路）；

批量操作单张表数据的时候，先对数据进行排序（避免形成等待环路）；

申请足够级别的锁，如果要操作数据，就申请排它锁；

尽量使用索引访问数据，避免没有 where 条件的操作，避免锁表；

如果可以，大事务化成小事务；

使用等值查询而不是范围查询查询数据，命中记录，避免间隙锁对并发的影响。

> https://juejin.cn/post/6844904072760262669

### 83.MySQL和 MariaDB的区别?

### 84.MySQL日志undo和redo的区别?

undo 日志用于记录事务开始前的状态，用于事务失败时的回滚操作；redo 日志记录事务执行后的状态，用来恢复未写入 data file 的已成功事务更新的数据。例如某一事务的事务序号为 T1，其对数据 X 进行修改，设 X 的原值是 0，修改后的值为 1，那么 Undo 日志为 <T1, X, 0>，Redo 日志为 < T1, X, 1>。

redo log 通常是 **物理** 日志，记录的是 **数据页** 的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。
 2.undo log 用来回滚行记录到某个版本。undo log 一般是逻辑日志，根据每行记录进行记录。

> https://juejin.cn/post/6860252224930070536

### 85.MySQL单表的最大记录数是多少?

MySQL本身并没有对单表最大记录数进行限制，但是从性能考虑，记录数过多肯定是有一定影响的

阿里巴巴《Java 开发手册》提出单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表

### 86.什么是表分区?

分区是一种表的设计模式，通俗地讲表分区是将一大表，根据条件分割成若干个小表。但是对于应用程序来讲，分区的表和没有分区的表是一样的。换句话来讲，分区对于应用是透明的，只是数据库对于数据的重新整理。

> https://segmentfault.com/a/1190000022780773
>
> https://www.jianshu.com/p/1cdd3e3c5b3c
>
> https://www.cnblogs.com/dw3306/p/12620042.html

### 87.表分区有什么好处?

- 与单个磁盘或文件系统分区相比，可以存储更多的数据。
- 对于那些已经失去保存意义的数据，通常可以通过删除与那些数据有关的分区，很容易地删除那些数据。相反地，在某些情况下，添加新数据的过程又可以通过为那些新数据专门增加一个新的分区，来很方便地实现。

### 88.表分区与分表的区别?

分表：指的是通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间成多个表。 分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。

### 89.MySQL支持的分区类型有哪些?

- RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区。
- LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择。
- HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。
- KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL 服务器提供其自身的哈希函数。必须有一列或多列包含整数值。

### 90.MySQL分区表有哪些限制因素?

1. 一个表最多只能有1024个分区（mysql5.6之后支持8192个分区）。
2. 在mysql5.1中分区表达式必须是整数，或者是返回整数的表达式，在5.5之后，某些场景可以直接使用字符串列和日期类型列来进行分区（使用varchar字符串类型列时，一般还是字符串的日期作为分区）。
3. 如果分区字段中有主键或者唯一索引列，那么所有主键列和唯一索引列都必须包含进来，如果表中有主键或唯一索引，那么分区键必须是主键或唯一索引。
4. 分区表中无法使用外键约束。
5. mysql数据库支持的分区类型为水平分区，并不支持垂直分区，因此，mysql数据库的分区中索引是局部分区索引，一个分区中既存放了数据又存放了索引，而全局分区是指的数据库放在各个分区中，但是所有的数据的索引放在另外一个对象中
6. 目前mysql不支持空间类型和临时表类型进行分区。不支持全文索引。

### 91.MySQL 为什么要分库分表?

数据库数据会随着业务的发展而不断增多，因此数据操作，如增删改查的开销也会越来越大。

再加上物理服务器的资源有限(CPU、磁盘、内存、IO 等)。最终数据库所能承载的数据量、数据处理能力都将遭遇瓶颈。

换句话说需要合理的数据库架构来存放不断增长的数据，这个就是分库分表的设计初衷。目的就是为了缓解数据库的压力，最大限度提高数据操作的效率。

### 92.MySQL 达到什么量需要分库分表?

阿里巴巴《Java 开发手册》提出单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表

### 93.MySQL 分库分表怎么做?

根据容量（当前容量和增长量）评估分库或分表个数 -> 选key（均匀）-> 分表规则（hash或range等）-> 执行（一般双写）-> 扩容问题（尽量减少数据的移动）。

### 94.MySQL分库分表工具有哪些?

1. sharding-sphere：jar，前身是sharding-jdbc；
2. TDDL：jar，Taobao Distribute Data Layer；
3. Mycat：[中间件](https://cloud.tencent.com/product/tdmq?from=10680)。

注：工具的利弊，请自行调研，官网和社区优先。

> https://cloud.tencent.com/developer/article/1623139

### 95.MySQL 分库分表会产生哪些问题?

（1）跨库关联查询

（2）分布式事务

（3）排序、分页、函数计算问题

（4）分布式 ID

（5）多数据源

> https://z.itpub.net/article/detail/23A4168E598B38BFFA57828C5C0D2E9C

### 96.MySQL批量插入，如何不插入重复数据?

ON DUPLICATE KEY UPDATE 

```java
<insert id="batchSaveUser" parameterType="list">
    insert into user (id,username,mobile_number)
    values
    <foreach collection="list" item="item" index="index" separator=",">
        (
            #{item.id},
            #{item.username},
            #{item.mobileNumber}
        )
    </foreach>
    ON duplicate KEY UPDATE id = id
</insert>
```

> https://segmentfault.com/a/1190000039912996

### 97.MySQL中为什么不建议使用 UTF-8?

### 98.MySQL为什么不建议用 UUID做主键?

### 99.MySQL提高并发可以调整哪些参数?

### 100.MySQL日期NOW和SYSDATE的区别?

mysql中日期函数NOW()和SYSDATE()都表示当前时间，NOW()取的是语句开始执行的时间，SYSDATE()取的是语句执行过程中动态的实时时间。

NOW()取自mysql的一个变量”TIMESTAMP”，这个变量在语句开始执行的时候就设定好了，因此在整个语句执行过程中都不会变化。

![image-20211007175145458](https://note-java.oss-cn-beijing.aliyuncs.com/img/image-20211007175145458.png)

> https://blog.csdn.net/mycms5/article/details/72763176

### 101.MySQL怎么查看当前数据库版本?

### 102.MySQL 常用的客户端有哪些?

### 103.一个查询的过程：

- 客户端发送一条查询给服务器
- 服务器端先检查查询缓存，如果命中了缓存，则立可返回存储在缓存中的结果。否则进入下一个阶段
- 服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。
- MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。
- 将结果返回给客户端

https://www.cnblogs.com/zhoutianyuan/p/11060483.html

### 104.mysql锁

> https://zhuanlan.zhihu.com/p/29150809

 **InnoDB行级锁和表级锁**

 **InnoDB锁模式：**

InnoDB 实现了以下两种类型的**行锁**：

- 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
- 排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是**表锁**：

- 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。
- 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。

**锁模式的兼容情况：**

![img](https://note-java.oss-cn-beijing.aliyuncs.com/img/v2-37761612ead11ddc3762a4c20ddab3f3_1440w.jpg)

（如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务； 反之， 如果两者不兼容，该事务就要等待锁释放。）

 **InnoDB加锁方法：**

- 意向锁是 InnoDB 自动加的， 不需用户干预。

- 对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB
  会自动给涉及数据集加排他锁（X)；

- 对于普通 SELECT 语句，InnoDB 不会加任何锁；
  事务可以通过以下语句显式给记录集加共享锁或排他锁：

- - 共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。
  - 排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁



- **隐式锁定：**

InnoDB在事务执行过程中，使用两阶段锁协议：

随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；

锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在**同一时刻**被释放。

- **显式锁定 ：**

```text
select ... lock in share mode //共享锁 
select ... for update //排他锁 
```

**select for update：**

在执行这个 select 查询语句的时候，会将对应的索引访问条目进行上排他锁（X 锁），也就是说这个语句对应的锁就相当于update带来的效果。

select *** for update 的使用场景：为了让自己查到的数据确保是最新数据，并且查到后的数据只允许自己来修改的时候，需要用到 for update 子句。

**select lock in share mode ：**in share mode 子句的作用就是将查找到的数据加上一个 share 锁，这个就是表示其他的事务只能对这些数据进行简单的select 操作，并不能够进行 DML 操作。select *** lock in share mode 使用场景：为了确保自己查到的数据没有被其他的事务正在修改，也就是说确保查到的数据是最新的数据，并且不允许其他人来修改数据。但是自己不一定能够修改数据，因为有可能其他的事务也对这些数据 使用了 in share mode 的方式上了 S 锁。

**性能影响：**
select for update 语句，相当于一个 update 语句。在业务繁忙的情况下，如果事务没有及时的commit或者rollback 可能会造成其他事务长时间的等待，从而影响数据库的并发使用效率。
select lock in share mode 语句是一个给查找的数据上一个共享锁（S 锁）的功能，它允许其他的事务也对该数据上S锁，但是不能够允许对该数据进行修改。如果不及时的commit 或者rollback 也可能会造成大量的事务等待。

**for update 和 lock in share mode 的区别：**

前一个上的是排他锁（X 锁），一旦一个事务获取了这个锁，其他的事务是没法在这些数据上执行 for update ；后一个是共享锁，多个事务可以同时的对相同数据执行 lock in share mode。

### 105.可重复读解决幻读问题

### 106.[mysql mvcc实现可重复读和读已提交](https://www.cnblogs.com/shenxiaobin/p/15142996.html)

https://blog.csdn.net/SCUTJAY/article/details/104653599
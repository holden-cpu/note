> 阅读：https://z.itpub.net/article/detail/CC3700B7B6B252FC6AFFB3BC03AB7C30

### 1.Redis 是什么?

- Redis（Remote Dictionary Server），即远程字典服务，是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key- Value 非关系型数据库，并提供多种语言的API。
-  Redis 的出现，很大程度补偿了memcached 这类 key/value 存储的不足，在部分场合可以对关系数据库起到很好的补充作用，它提供了Java， C/C++,C#,PHP,JavaScript,Perl,Object- C，Python，Ruby，Erlang 等客户端，使用很方便。

Redis是一个开源的<font color='red'>key-value</font>存储系统。它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和 hash（哈希类型）。

Redis是一个使用ANSI C编写的开源、包含多种数据结构、支持网络、基于内存、可选持久性的键值对存储数据库

![img](https://note-java.oss-cn-beijing.aliyuncs.com/img/wps16.png)

### 2. Redis 有哪些应用场景?

缓存系统（“热点”数据：高频读、低频写）、排行榜、计数器、分布式会话、分布式锁、消息队列系统、社交网络、消息系统 和实时系统

- 1、缓存 
  - 缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在 Redis用在缓存的场合非常多。 
- 2、排行榜 
  - 很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。 
- 3、计数器
  -  什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。Redis提供的incr命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。
-  4、分布式会话 
  - 集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以Redis等内存数据库为中心的session服务，session不再由容器管理，而是由session服务及内存数据库管理。 如，单点登录
- 5、分布式锁
  -  在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。
-  6、社交网络
  -  点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。
-  7、最新列表 
  - Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。 
- 8、消息系统 
  - 消息队列是大型网站必用中间件，如ActiveMQ、 RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。

### 3. Redis 有什么优势?

响应快。

高并发下给数据库做缓存，避免数据库撑不住

- 1、性能高，速度快 Redis命令执行速度非常快，官方给出的读写性能可以达到10W/秒。 

  为什么会如此之快呢? 有以下几个因素∶

  -  数据存储在内存中，直接与内存连接。
  - 由相对底层的C语言实现，离操作系统更近。
  - 实现源码很精湛，仅仅几万行代码，简单稳定。 
  - 使用了单线程模型，无多线程竞争、锁等问题。 

- 2、丰富的数据结构 Redis与其他的内存数据库不同的是，Redis拥有丰富的数据类型，如字符串、哈希、列表、集合、有序集合等。正是因为Redis丰富的数据类型，所有它能应用的场景非常多。

-  3、丰富的特性 除了支持丰富的数据结构外，还支持以下高级功能。

  -  支持键过期功能，可以用来实现定时缓存。
  - 支持发布/订阅功能，可以有来实现消息队列。
  - 支持事务功能，可以保证多条命令的事务性。
  - 支持供管道功能，能够批量处理命令。
  - 支持Lua脚本功能。 
  - 支持集群分片和数据复制功能。
  - 支持内存数据持久化硬盘功能。

-  4、丰富的客户端 

  >   http∶//www.redis.cn/clients.html 

  从官网给出的客户端列表可以看出，各种各种的语言都能接入到Redis，接入包括了所有的主流开发语言。

   目前使用Redis的公司非常多，国内外都有很多重量级的公司在用。所以，现在学习Redis是大势所趋，学好Redis能为自己在日后的工作谋生中增加一个强有利的竞争手段。

### 4. Redis 为什么这么快?

内存存储：Redis是使用内存(in-memeroy)存储,没有磁盘IO上的开销

单线程实现：Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销

非阻塞IO：Redis使用多路复用IO技术，在poll，epool，kqueue选择最优IO实现

优化的数据结构：Redis有诸多可以直接应用的优化数据结构的实现，应用层可以直接使用原生的数据结构提升性能

- 数据存储在内存中，直接与内存连接。

- 由相对底层的C语言实现，离操作系统更近。

- 实现源码很精湛，仅仅几万行代码，简单稳定。 

- 使用了单线程模型，无多线程竞争、锁等问题。

### 5. Redis 主要消耗什么物理资源?

内存

因为redis的数据都是存储在内存当中。内存数据库相比一般的关系型数据库，读取速度要更快，但是消耗的内存资源会更多。

### 6.Redis 为什么把所有数据放到内存中?

因为 Redis 的定位就是一个<font color='red'>内存数据库</font>。<font color='red'> 内存的读取速度是最快的</font>，如果放到硬盘，磁盘 IO 的速度势必会严重影响 Redis 的性能，那就和一般的关系数据库相比没什么优势可言，而且随着现在内存硬件成本的降低，内存已经不是问题，性能才是关键，现在硬盘只是成为了一种持久化方案而已。

Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以Redis具有快速和数据持久化的特性。

如果不将数据放到内存中，磁盘的I/O速度会严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。如果设置了最大使用的内存，则数据已有记录数达到内存限值后将不能继续插入新值。

### 7.Redis 命令是原子性的吗?

是。因为Redis的单线程

对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。

### 8.Redis 怎么测试连通性?

ping命令。

### 9.Redis 到底是单线程还是多线程?

单线程

### 10.Redis 和 Memcache 有什么区别?

最主要的几个区别∶ 

- 1、存储方式 Redis 支持数据持久性，可以持久化数据到硬盘上。 Memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 
- 2、数据类型 Redis 有丰富的数据结构，Memecache 只支持简单的字符串类型。
-  3、数据大小 Redis 单 个 value 的 最 大 限 制 是 512M， Memcached 最大限制是 1MB。 但是 Memcache 在存储 100K 以上的数据，性能稍微好一点。

Redis是单线程的的IO复用模型，对于单存只有IO操作来说，单线程可以将速度优势发挥到最大，但对于一些计算功能单线程模型会影响整体的吞吐量。memcache是多线程的，非阻塞IO复用的网络模型，分为监听主线程和worker子线程，多线程可以发挥多核优势，但加锁带来了性能损耗。

### 11.Redis 支持哪些数据类型?

string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。

### 12.Redis 默认支持多少个数据库?怎么修改?

Redis默认支持16个数据库，可以通过调整Redis的配置文件redis/redis.conf中的databases来修改这一个值，设置完毕后重启Redis便完成配置。

客户端与Redis建立连接后会默认选择0号数据库，不过可以随时使用SELECT命令更换数据库。

### 13.Redis 最大 key 大小?

Key的大小上限为512M。

建议key的大小不超过1KB，这样既节约存储空间，也利于Redis进行检索。

### 14.Redis String 值最大存储多少?

String类型的value值上限为512M。

![image-20210929002638537](https://note-java.oss-cn-beijing.aliyuncs.com/img/image-20210929002638537.png)

### 15.Redis 事务有什么用?

Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。

Redis事务的主要作用就是<font color='red'>串联多个命令防止别的命令插队</font>。

### 16.Redis 事务相关的命令有哪几个?

Multi、Exec、discard

### 17.Redis 事务是原子性的吗?

> https://blog.51cto.com/u_14799494/2490313

### 18.Redis 持久化有什么用?

- 持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。

### 19.Redis 有哪几种持久化方式?

1. AOF
2. RDB

### 20.Redis 持久化方式如何选择?

- 官方推荐两个都启用。
- 如果对数据不敏感，可以选单独用RDB。
- 不建议单独用 AOF，因为可能会出现Bug。
- 如果只是做纯内存缓存，可以都不用。 

### 21.如何保证 Redis 中的数据都是热点数据?

> https://blog.csdn.net/u013308490/article/details/87737810

将淘汰策略为volatile-lru或者allkeys-lru。 

### 22.Redis 内存满了怎么办?

- 增加内存；maxmemory

- 使用内存淘汰策略。maxmemory-policy

- Redis集群。

### 23.Redis 怎么配置最大内存容量?

`maxmemory`

### 24.Redis 有哪些淘汰策略?

| 策略            | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| volatile-lru    | 只对设置了expire过期时间的key生效，优先删除最近最少使用(least recently used ,LRU) 的 key，直到有可用的内存，如果没有可删除的key并且内尺还是不够，则报错。 |
| allkeys-lru     | 所有key通用;优先删除最近最少使用(least recently used ,LRU)的key，直到有可用的内存，如果没有可删除的key并且内尺还是不够，则报错。 |
| volatile-lfu    | Redis4.0新增的策略。只对设置了expire过期时间的key生效，优先删除最不常用(least frequently used ,LFU) 的 key，直到有可用的内存，如果没有可删除的key并且内尺还是不够，则报错。 |
| allkeys-lfu     | Redis4.0新增的策略。所有key通用;优先删除最不常用(least frequently used , LFU)的key，直到有可用的内存，如果没有可删除的key并且内尺还是不够，则报错。 |
| volatile-random | 只对设置了expire过期时间的key生效，随机删除一部分key，直到有可用的内存，如果没有可删除的key并且内尺还是不够，则报错。 |
| allkeys-random  | 所有key通用，随机删除一部分key，直到有可用的内存，如果没有可删除的key并且内尺还是不够，则报错。 |
| volatile-ttl    | 只对设置了expire过期时间的key生效，优先删除剩余时间(time to live,TTL) 最短的key，直到有可用的内存，如果没有可删除的key并且内尺还是不够，则报错。 |
| noeviction      | 默认策略，不删除任何key，在进行写操作时返回错误信息          |

> https://www.cnblogs.com/lifan1998/p/15001630.html

redis并不会准确地删除所有键中最近最少使用的键，而是随机抽取n个键，删除这n个键中最近最少使用的键。这个n也是可以设置的，对应位置是配置文件中的**maxmeory-samples。**

LRU (Least recently used) 最近最少使用，如果数据最近被访问过，那么将来被访问的几率也更高，也就不会被淘汰。也就是优先淘汰最长时间未被使用的数据，这个主要针对的是访问时间，可能存在某些key值在前一段时间访问很频繁，但是最近没被访问，从而被 LRU 算法删除。Java中可以通过继承LinkedHashMap快速实现一个LRU Cache，此前我们学习过了。

LFU (Least frequently used) 最不经常使用，如果一个数据在最近一段时间内使用次数很少，那么在 将来一段时间内被使用的可能性也很小，就会被淘汰。也就是优先淘汰一定时期内被访问次数最少的数据，这个主要针对的是访问频率，可能存在某些 key 值在前一段时间访问很频繁，但是最近一段时间访问比较少，从而被 LRU 算法删除。

### 25.Redis 为什么新增了LFU 淘汰策略?

https://www.cnblogs.com/linxiyue/p/10945216.html

https://www.cnblogs.com/linxiyue/p/10955533.html

### 26.Redis 淘汰策略LRU 和 LFU 的区别?

https://www.jianshu.com/p/c8aeb3eee6bc

### 27. Redis 怎么配置淘汰策略?

```
maxmemory-policy 淘汰策略
```

### 28.Redis 过期键的删除策略有哪些?

> http://blog.itpub.net/70000438/viewspace-2788091

- 定时删除
  1. 在设置key的过期时间的同时，创建一个定时器，让定时器在key的过期时间来临时，立即执行对key的删除操作；
  2. 定时删除操作对于内存来说是友好的，内存不需要操作，而是通过使用定时器，可以保证尽快的将过期key删除，但是对于CPU来说不是友好的，如果过期key比较多的话，起的定时器也会比较多，每一个定时器会占用到CPU的资源；
- 惰性删除
  1. 不管key有没有过期都不主动删除，但是每次从键空间中获取键值时，都检查取得的key的过期时间，如果过期的话，返回null，然后删除key即可；
  2. 惰性操作对于CPU来说是友好的，过期key只有在程序读取时判断是否过期才删除掉，而且也只会删除这一个过期键，但是对于内存来说是不友好的，如果多个key都已经过期了，而这些key又恰好没有被访问，那么这部分的内存就都不会被释放出来；
- 定期删除
  1. 每隔一段时间，程序就对数据库进行一次检查，删除掉过期key；
  2. 定期删除是上面两种方案的折中方案，每隔一段时间来删除过期key，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响，除此之外，还有效的减少内存的浪费；但是该策略的难点在于间隔时长，这个需要根据自身业务情况来进行设置，并且可能由于扫描不及时，导致过期的key也被返回。

目前，Redis采用的是惰性删除+定期删除的方案；Redis 的定期扫描只会扫描设置了过期时间的键，Redis 通过一个单独的过期字典expires（可以看作是 hash 表）来保存设置了过期时间的数据过期的时间，所以不会出现扫描所有键的情况，即使如此，redis也是默认是每隔 100ms 就随机抽取过期字典中的 key，检查其是否过期，如果过期就删除。如果不定时随机抽查而是全部扫描，那么将可能有很长的时间导致服务对外不可用，这是无异于一场灾难。

由于是随机扫描，那么对于已经过期但没有被扫描到的key怎么办呢，没关系，还有惰性删除，在获取某个 key 的时候，Redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，返回null。

### 29.Redis 如何提高多核CPU利用率?

可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）

### 30.Redis 如何实现大量数据插入?

Redis 2.6 开始 redis - cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工作。

一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应，这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。

这就是管道（pipeline），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。

### 31.Redis 的回收进程如何工作的?

一个客户端运行了新的命令，添加了新的数据。 redis检查内存使用情况，如果大于maxmemory的限制，则根据设定好的策略进行回收。

一个新的命令被执行等等，所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断回收回到 边界以下。

如果一个命令的结果导致大量内存被使用(例如很大的集合的交集保存到一个新的键)，不用多久内存限制就会被这个内存使用量超越。 

### 32.Redis 中的管道有什么用?

管道技术(Pipeline)是客户端提供的一种批处理技术，用于<font color='red'>一次处理多个Redis命令</font>，从而提高整个交互的性能。

通常情况下Redis是单线程执行的，客户端先向服务器发送请求，服务端接收并处理请求、然后把结果返回给客户端，这种处理模式在非频繁请求时不会出现任何问题。

但如果出现集中大批量请求时，因为每个请求都要经历先请求再响应的过程，这就会造成网络资源浪费。此时就需要管道技术来把所有的命令整合起来，一次性发送给服务端，服务端处理完毕之后一次性响应给客户端，这样就大大地提高了Redis的响应速度。

> https://www.cnblogs.com/traditional/p/13304860.html

33.Redis 有哪些高可用方案?

- 主从复制
- 哨兵模式
- 集群

> https://www.jianshu.com/p/5de2ab291696

### 34.Redis 集群如何选择数据库?

Redis 集群目前无法做数据库选择，默认在 0 数据库。

### 35.Redis 哈希槽怎么理解?

Redis 集群没有使用一致性 hash，而是引入了哈希槽的概念。

Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 算法计算的结果，对 16384 取模后放到对应的编号在 0-16383 之间的哈希槽，集群的每个节点负责一部分哈希槽

[为什么Redis集群有16384个槽](https://www.cnblogs.com/rjzheng/p/11430592.html)

### 36.Redis 支持的 Java 客户端有哪些?

- Redisson
- Jedis
- Lettuce

### 37.Redisson 是什么框架?

Redisson是Redis服务器上的分布式可伸缩Java数据结构----驻内存数据网格(In-Memory Data Grid，IMDG)。底层使用netty框架，并提供了与java对象相对应的分布式对象、分布式集合、分布式锁和同步器、分布式服务等一系列的Redisson的分布式对象。

Redisson在Redis的基础上实现了java缓存标准规范；Redisson还提供了Spring Session回话管理器的实现。

> https://www.jianshu.com/p/8853b34f7c8b 

### 38.Redis 和 Redisson有什么关系?

Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。

### 39.Jedis、lettuce和Redisson 对比有什么优缺点?

**1. Jedis**

```
github: github.com/xetorthio/j…
```

Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。支持基本的数据类型如：String、Hash、List、Set、Sorted Set。

优点：比较全面的提供了Redis的操作特性，相比于其他Redis 封装框架更加原生。

编程模型： 使用阻塞的I/O，方法调用同步，程序流需要等到socket处理完I/O才能执行，不支持异步操作。Jedis客户端实例不是线程安全的，所以需要通过连接池来使用Jedis。

**2. Lettuce**

```
官网：lettuce.io/
github: github.com/lettuce-io/…
```

高级Redis客户端，用于线程安全同步，异步和响应使用，支持集群，Sentinel，管道和编码器。

优点：适合分布式缓存框架。

编程模型：基于Netty框架的事件驱动的通信层，其方法调用是异步的。Lettuce的API是线程安全的，所以可以操作单个Lettuce连接来完成各种操作。

**3.Redisson**

```
官网： redisson.org/
github: github.com/redisson/re…
```

Redisson实现了分布式和可扩展的Java数据结构。Redisson不仅提供了一系列的分布式Java常用对象，基本可以与Java的基本数据结构通用，还提供了许多分布式服务。

优点： 促使使用者对Redis的关注分离，让使用者能够将精力更集中地放在处理业务逻辑上，提供很多分布式相关操作服务，例如，分布式锁，分布式集合，可通过Redis支持延迟队列。

**第三方框架整合：**

提供了和Spring框架的各项特性类似的，以Spring XML的命名空间的方式配置RedissonClient实例和它所支持的所有对象和服务

在Redis的基础上实现了Java缓存标准规范，并完整的实现了Spring框架里的缓存机制

提供了Spring Session会话管理器的实现

编程模型：基于Netty框架的事件驱动的通信层，其方法调用是异步的。Redisson的API是线程安全的，所以可以操作单个Redisson连接来完成各种操作。

**4.总结**

Jedis中的方法调用是比较底层的暴露的Redis的API，也即Jedis中的Java方法基本和Redis的API保持着一致，了解Redis的API，也就能熟练的使用Jedis。而Redisson中的方法则是进行比较高的抽象，每个方法调用可能进行了一个或多个Redis方法调用。

### 40.Redis 为什么不提供Windows版本?

因为目前 Linux 版本已经相当稳定，且Linux操作系统自带的epoll相关函数, 在高并发情况下性能一般比windows的select函数性能较好，为了高性能起见, Redis官网不提供windows 版本。

### 41.Redis 如何设置密码访问?

**设置**

1. 在 /etc/redis.conf 配置文件下，需要重启服务生效。

```
requirepass 密码
```

2. 也可在客户端登录后再设置，此方式不需要重启服务就能生效，但是服务器重启后还是会优先使用配置文件中的密码。

```java
config set requirepass 密码
```

**访问**

1. 客户端登录时 -a 参数输入认证密码 ，

```
 ./redis-cli -h 主机 -p 端口号 -a 密码
```

2. 不使用 -a

```
./redis-cli -h 主机 -p 端口号
127.0.0.1:6379> auth 认证密码
```

**在Redis集群中使用认证密码**

如果Redis服务器，使用了集群。除了在master中配置密码外，也需要在slave中进行相应配置。在slave的配置文件中找到如下行，去掉注释并修改与master相同的密码即可：

```
 masterauth master-password
```

### 42.Redis 如何分析慢查询操作?

https://www.cnblogs.com/javastack/p/9632791.html

### 43.什么是缓存预热?

新的缓存系统没有任何缓存数据，在缓存重建数据的过程中，系统性能和数据库负载都不太好，所以最好是在系统上线之前就把要缓存的热点数据加载到缓存中，这种缓存预加载手段就是预热。

### 44.什么是缓存热备?

缓存热备即当一台服务器不可用时能实时切换到备用缓存服务器，不影响缓存使用。集群模式下，每个主节点都会有一个或多个从几点来当备用，一旦主节点挂掉，从节点立即充当主节点使用。

### 45.什么是缓存雪崩、缓存穿透、缓存击穿?

https://blog.csdn.net/a745233700/article/details/88088669

### 46.什么是缓存抖动?如何解决缓存抖动?

缓存抖动，一般是指由于某个<font color='red'>缓存节点故障</font>导致该节点上的缓存数据不可用.

推荐的做法是通过一致性 Hash 算法来解决。

### 47.什么是缓存无底洞?如何解决缓存无底洞?

为了满足业务大量加节点，但是性能没提升反而下降。

- 分布式缓存数据量特别大时，批量获取多个key由于分布在多个不同实例，需要多次网络IO，性能下降。
- 解决方案：
  - 串行`MGET`，将N个key拆解为N次`GET`操作。实现简单，性能较低。
  - 串行IO，计算每个key对应的节点，分别访问对应的节点。实现简单，性能较低。
  - 并行IO，将串行IO的网络请求改为多线程执行，实现复杂，性能较好。
  - hash-tag，强制将多个key分配到一个节点上，性能最高，但维护成本高，容易出现数据倾斜。

### 48.如何解决 Redis 和数据库双写一致性问题?

- 在同一时刻，Redis和DB中的数据不一致。
- 解决方案：
  - 如果不要求强一致性，只要保证最终一致性，可以给key设置较短的过期时间。
  - 先删缓存，再更新数据库。这样可能产生的问题：线程1删除缓存，线程2读取数据库并写入缓存，线程1更新数据库，此时缓存中缓存了脏数据。因此，需要延时双删等策略防止脏数据。
  - 先更新数据库，再删除缓存。这里可能由于删缓存失败导致产生脏数据。解决方法：使用消息队列不断重试确保删除缓存成功；订阅DB的binlog，尝试删除缓存，如果失败放入消息队列不断重试。

### 56.Redis 有哪些危险命令?如何防范?

### 57.Redis 如何统计独立用户访问量?

## Redis的分区

### Redis的分区作用是什么？

- **扩展数据库容量**，可以利用多台机器的内存构建更大的数据库
- **扩展计算能力**，分区可以在多核和多计算机之间弹性扩展计算能力，在多计算机和网络适配器之间弹性扩展网络带宽

### Redis分区有哪些实现方案？

在介绍Redis集群的实现方案时已经介绍过了**客户端分区**和**代理分区**，常见的Redis分区方案主要有以下三种：

- **客户端分区**：客户端决定数据被存到哪个Redis节点或者从哪个节点读取
- **代理分区**：客户端将请求发送到代理，而不是直接发送到Redis节点，代理根据分区策略将请求发送到Redis节点上
- **查询路由**：客户端随机请求任意一个Redis节点，这个Redis节点将请求转发到正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，并不是直接将请求从一个Redis节点转发到另一个Redis节点，而是在客户端的帮助下直接重定向到正确的[redis](https://www.nowcoder.com/jump/super-jump/word?word=redis)节点

### Redis分区的缺点？

- **不支持多个键的操作**，例如不能操作映射在两个Redis实例上的两个集合的交叉集。（其实可以做到这一点，但是需要间接的解决）
- **Redis不支持多个键的事务**
- **Redis是以键来分区**，因此不能使用单个大键对数据集进行分片，例如一个非常大的有序集
- **数据的处理会变得复杂**，比如你必须处理多个RDB和AOF文件，在多个实例和主机之间持久化你的数据
- **添加和删除节点也会变得复杂**，例如通过在运行时添加和删除节点，Redis集群通常支持透明地再均衡数据，但是其他系统像客户端分区或者代理分区的特性就不支持该特性。不过*Pre-sharding*(预分片)可以在这方面提供帮助。

## Redis的分布式问题

### 什么是分布式锁？

相信大家对程序中的锁并不陌生，无论是在并发编程或者Java虚拟机都有学到过。

锁在程序中的作用主要是同步，就是保证共享资源在同一时刻只能被同一个线程访问。

分布式锁则是为了保证在分布式场景下，共享资源在同一时刻只能被同一个线程访问，或者说是用来控制分布式系统之间同步访问共享资源。举个简单例子，如下图

![img](https://uploadfiles.nowcoder.com/files/20220228/115285789_1646044559433/22ceda965737d90b6ee36e49fe9d70b9.png)

从上图可以看出，变量A在三个服务器中都有涉及到，如果不对其进行控制的话，三个服务器中的变量A很难做到同步，解决这个问题的方法就是分布式锁。

### 分布式锁具有哪些特性？

- 互斥性：在任意时刻，同一条数据只能被一台机器上的一个线程执行
- 高可用性：当部分节点宕机后，客户端仍可以正常地获取锁和释放锁
- 独占性：加锁和解锁必须同一台服务器执行，不能在一个服务器上加锁，在另一个服务器上释放锁
- 防锁超时：如果客户端没有主动释放锁，服务器会在一定时间后自动释放锁， 防止客户端宕机或者网络异常导致宕机

### 分布式锁的实现方法？

基本思路就是要在整个系统中提供一个**全局、唯一**的获取锁的“东西”，然后每个系统在需要加锁时，都去问这个“东西”拿到一把锁，这样不同的系统拿到的就可以认为是同一把锁。

常见的分布式锁实现方案有三种：

**基于关系型数据库**：

**优点**：直接借助数据库容易理解

**缺点**：在使用关系型数据库实现分布式锁的过程中会出现各种问题，例如数据库单点问题和可重入问题，并且在解决过程中会使得整个方案越来越复杂

**基于Redis**：

**优点：**性能好，实现起来较为方便

**缺点**：

- key的过期时间设置难以确定，如何设置的失效时间太短，方法没等执行完，锁就自动释放了，那么就会产生并发问题。如果设置的时间太长，其他获取锁的线程就可能要平白的多等一段时间。
- Redis的集群部署虽然能解决单点问题，但是并不是强一致性的，锁的不够健壮

**基于zoo[keep](https://www.nowcoder.com/jump/super-jump/word?word=keep)er**：

**优点**：有效地解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题，实现起来较为简单。

**缺点：**性能上不如使用缓存实现分布式锁

三种方案的对比

|                             方案                             | 复杂度 | 性能 | 可靠性 | 学习成本 |
| :----------------------------------------------------------: | :----: | :--: | :----: | :------: |
|                       基于关系型数据库                       |   低   |  低  |   低   |    低    |
|                          基于Redis                           |   中   |  高  |   中   |    中    |
| 基于zoo[keep](https://www.nowcoder.com/jump/super-jump/word?word=keep)er |   高   |  中  |   高   |    高    |

### Redis如何实现分布式锁？

前面讲过了分布式锁的特性，其实实现分布式锁就是围绕着这些展开的

Redis实现分布式锁的主要命令：**SETNX**，该命令的作用是当key不存在时设置key的值，当Key存在时，什么都不做。

先来看最简单的实现方式，如下图

![img](https://uploadfiles.nowcoder.com/files/20220228/115285789_1646044559473/ddf2f18770b539ccac9c0dd8600bd479.png)

从上图可以看到主要两个关键步骤，**加锁和解锁**。

但是这个简陋的分布式锁存在很多问题，并不能满足上述介绍的分布式锁的特性，

比如，当线程1执行到上图中**执行业务**这步时，业务代码突然出现异常了，无法进行**删除锁**这一步，那就完犊子了，死锁了，其他线程也无法获取到锁了（因为SETNX的特性）。

#### 改进方案1

那咋整呢？

一提到异常，有人想起了try-catch-finally了，把**删除锁**的操作放到finally代码块中，就算出现异常，也是能正常释放锁的，**执行业务**出现异常这个问题确实解决了。但这玩意并不靠谱，如果Redis在**执行业务**这步宕机了呢，finally代码块也不会执行了。

#### 改进方案2

其实这个问题很好解决，只需给锁设置一个过期时间就可以了，对key设置过期时间在Redis中是常规操作了。就是这个命令`SET key value [EX seconds][PX milliseconds] [NX|XX]`

- EX second: 设置键的过期时间为second秒；
- PX millisecond：设置键的过期时间为millisecond毫秒；
- NX：只在键不存在时，才对键进行设置操作；
- XX：只在键已经存在时，才对键进行设置操作；
- SET操作完成时，返回OK，否则返回nil。

那现在这个方案就完美了吗？显然没有

例如，线程1获取到了锁，并设置了有效时间10秒，但线程1在**执行业务**时超过了10秒，锁到期自动释放了，在锁释放后，线程2又获取了锁，在线程2执行业务时，线程1执行完了，随后执行了**删除锁**这一步，但是线程1的锁早就到期自动释放了，他删除的是线程2的锁！！！

上面这个例子说的有点乱，突然想到一个现实生活中的例子，把Redis比作一个厕所，张三去上厕所，关上了门（获取锁，并设置了10秒），上到一半（10秒到了，门自动开了），这时李四进去了，关上了门（获取锁，并设置了10秒），张三上完了厕所，把门打开了走了（执行了删除锁操作）

上面这个荒诞的例子说明了方案2有两处不合理的地方，第一是张三厕所没上完，李四怎么能进去呢？他们上厕所产生了冲突，第二是张三上完厕所怎么能打开李四的门呢（分布式锁的特性，加锁和解锁必须同一台服务器执行）？

#### 改进方案3

其实看起来方案2的问题很容易解决，只需要把锁的过期时间设置的非常长，就可以避免这两个问题，但是这样并不可行，因为这样相当于回到最简陋的方案（会导致李四一直上不到厕所）。

那如何能让李四上到厕所，还不会让自己锁的门被张三打开门呢？

**很简单，为锁加一个标识，例如生成一个UUID，作为锁的标识，每个线程获取锁时都会生成一个不同的UUID作为锁的标识，在进行删除锁时会进行判断，锁的标识和自己生成UUID相等时才进行删除操作，这样就避免线程1释放了线程2的锁。**（相当于自己上自己的锁，不要计较为什么张三在李四上厕所时不需要李四的钥匙就能离开厕所这种事，上厕所和分布式锁逻辑并不完全相同，只是简单类比）

那怎么解决李四未等张三上完厕所就进厕所呢？（如何确定锁的过期时间）

**可以在加锁时，先设置一个预估的过期时间，然后开启一个守护线程，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行续期，重新设置过期时间。**

好了，张三和李四上厕所的问题解决了。

那方案3就没有其他问题了吗？其实还是有的，比如目前的分布式锁还不具备可重入性（同一线程可以重复获取锁，解决线程需要多次进入锁内执行任务的问题）

#### 改进方案4

参考其他重入锁的实现，可以通过对锁进行重入计数，加锁时加 1，解锁时减 1，当计数归 0 时才能释放锁。

那现在方案就没有问题了吗，其实还有

比如，线程1获取了锁，线程2没有获取到锁，那么线程2怎么知道线程1啥时候释放了锁，进而再去获取锁呢？

#### 改进方案5

方案4中问题的解决方案，一般以下两种解决方案：

- 可以通过客户端轮询的方式，就是线程2过一会就来看看是不是能获取锁了。这种方式比较消耗服务器资源，当并发量比较大时，会影响服务器的效率。
- 通过Redis的发布订阅功能，当获取锁失败时，订阅锁释放消息，获取锁成功后释放时，发送锁释放消息。

那现在这个方案完美了吗？也还没有

目前讨论的都是[redis](https://www.nowcoder.com/jump/super-jump/word?word=redis)是单节点的情况，如果这个节点挂了，那么所有的客户端都获取不到锁了

#### 改进方案6

为了实现多节点Redis的分布式锁，Redis的作者提出了RedLock[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)。

这是RedLock[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)官网的地址，https://redis.io/topics/distlock，英文好的建议直接看官方文档，毕竟我这四六级飘过的人也可能理解的不准确，下面的内容主要是参考官网内容。

##### 首先介绍保证分布式锁的有效性和安全性的要求：

- **互斥性**：在任何给定时刻，只有一个客户端可以持有一个锁
- **释放死锁**：即使锁定资源的客户端崩溃或被分区，也可以释放锁
- **容错性**：只要大多数Redis节点都在运行，客户端就能够获取和释放锁。

##### 为什么基于故障转移实现的Redis分布式锁还不够用？

官网中举了一个例子：

客户端A获得主服务器上的锁，然后主服务器向从服务器复制数据的过程中崩了，导致数据没有复制到从数据库中，这时会在从服务器中选出来一个升级为主服务器，但新的主服务器中并没有客户端A设置的锁。所以客户端B也可以获取到锁，违背了上面说的**互斥性**

这就解释为什么需要RedLock[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)

##### RedLock[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)

假设有5个完全独立的Redis服务器，多节点Redis实现的RedLock[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)如下

- 获取当前时间戳
- 客户端尝试在5个实例中按顺序获取锁，在所有实例中使用相同的键名和随机值。当在每个实例中设置锁时，需要将锁的获取时间设置为比锁过期短很多。例如，如果锁自动释放时间为10秒，则锁的获取时间在5-50毫秒。这是为了不要过长时间等待已经关闭的Redis实例,如果一个Redis实例不可用，我们应该尽快尝试获取下一个Redis实例的锁。
- 客户端通过从当前时间中减去步骤1中获得的时间戳，计算出获取锁所需的时间。当且仅当客户端能够在大多数实例(至少3个)中获得锁，并且花费在获取锁的总时间小于锁的有效性时间时，该锁被认为已经获得。
- 如果获得了锁，锁真正的有效时间为锁初始设置的有效时间（过期时间）减去第三步的时间，例如，锁初始有限时间为5s，获取锁花了0.5s，则锁真正的有效时间为4.5s（忽略了时钟漂移，时间漂移指指两个电脑间时间流速基本相同的情况下，两个电脑（或两个进程间）时间的差值）
- 如果客户端由于某些原因无法获得锁(要么无法锁定N/2+1个Redis实例，要么有锁的有效时间为负数)，客户端将尝试解锁所有Redis实例（即使是它认为无法锁定的Redis实例）。

##### RedLock[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)是异步的吗？

可以看成同步[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)，虽然没有跨进程的同步时钟，但每个进程（多个电脑）的本地时间仍然大致以相同的速度流动，与锁的自动释放时间相比，误差较小，将其忽略的话，则可以看成同步[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)。

##### RedLock失败重试

当客户端无法获取到锁时，应该在随机时间后重试，并且理想的客户端应该并发地将所有命令同时发给所有Redis实例。对于已经获取锁的客户端要在完成任务后及时释放锁，这样其他客户端就不需要等锁自动过期后再获取。如果在获取锁后，在主动释放锁前无法连接到Redis实例，就只能等锁自动失效了。

##### 释放锁

释放锁很简单，只要释放所有实例中的锁，不需要考虑是否释放成功（释放时会判断这个锁的value值是不是自己设置的，避免释放其他客户端设置的锁）

##### RedLock的 Safety arguments

- 假设客户端可以获取到大多数Redis实例，并且所有Redis实例具有相同的key和过期时间，但不同的Redis实例的key是不同的时间设置的（获取锁的时间不可能完全一致），所以过期时间也不同，假设获取第一个Redis实例的锁的时间为T1,最后一个为T2，则客户端获得锁的最小有效时间为key的有效时间-（T2-T1）-时钟漂移。
- 为什么需要获取一半以上的Redis实例的锁才算获取到锁成功呢？因为如果获取不到一半也算成功的话会导致多个客户端同时获取到锁，违背了互斥性
- 一个客户端锁定大多数Redis实例所需的时间大于或者接近锁的过期时间时，会认为锁无效，并解锁所有Redis实例

##### RedLock崩溃的相关解决方法

场景：客户端A在成功获取锁后，如果所有Redis重启，这时客户端B就可以再次获取到锁，违背了互斥性

解决方法：开启AOF持久化，可以解决这个问题，但是AOF同步到磁盘上的方式默认是每秒一次，如果1秒内断电，会导致1秒内的数据丢失，如果客户端是在这1秒内获得的锁，立即重启可能会导致锁的互斥性失效，解决方法是每次Redis无论因为什么原因停掉都要等key的过期时间到了再重启（延迟重启），这么做的缺点就是在等待重启这段时间内Redis处于关闭的状态。

最后，上面的方案6还有其他问题吗？其实还是有的，不过还有一种更适合Java的强大方案是Redisson，有兴趣的小伙伴可以去了解下

### Redis并发竞争key问题应该如何解决？

Redis并发竞争key就是多个客户端操作一个key，可能会导致数据出现问题，主要有以下几种解决办法：

- **乐观锁**，`watch` 命令可以方便地实现乐观锁。`watch` 命令会监视给定的每一个key，当 `exec` 时如果监视的任一个key自从调用watch后发生过变化，则整个事务会回滚，不执行任何动作。不能在分片集群中使用
- 分布式锁，适合分布式场景
- 时间戳，适合有序场景，比如A想把key设置为1，B想把key设置为2，C想把key设置为3，对每个操作加上时间戳，写入前先比较自己的时间戳是不是早于现有记录的时间戳，如果早于，就不写入了
- 消息队列，串行化处理

### 什么是RedLock

见上文Redis实现分布式锁的方案6

## Redis的缓存问题

### 说下什么是缓存雪崩、缓存穿透、缓存击穿，及它们的解决方案

> 这是一个非常高频的面试题，也非常容易掌握，比较麻烦的是总是分不清这三个哪个是哪个

下图是一个正常的系统架构图，其中缓存的作用是**减轻数据库的压力，提升系统的性能**，无论是缓存雪崩、缓存击穿还是缓存穿透都是缓存失效了导致数据库压力过大。

![img](https://uploadfiles.nowcoder.com/files/20220228/115285789_1646044559431/448647c8e46df8929269a5fd9fde6f5a.png)

#### 缓存雪崩

##### 什么是缓存雪崩？

缓存雪崩是指在某一个时刻出现大规模的缓存失效的情况，大量的请求直接打在数据库上面，可能会导致数据库宕机，如果这时重启数据库并不能解决根本问题，会再次造成缓存雪崩。

##### 为什么会造成缓存雪崩？

一般来说，造成缓存雪崩主要有两种可能

- Redis宕机了
- 很多key采取了相同的过期时间

##### 如何解决缓存雪崩？

- 为避免Redis宕机造成缓存雪崩，可以搭建Redis集群
- 尽量不要设置相同的过期时间，例如可以在原有的过期时间加上随机数
- 服务降级，当流量到达一定的阈值时，就直接返回“系统繁忙”之类的提示，防止过多的请求打在数据库上，这样虽然难用，但至少可以使用，避免直接把数据库搞挂

#### 缓存击穿

##### 什么是缓存击穿？

缓存雪崩是大规模的key失效，而缓存击穿是一个热点的Key，有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增，这种现象就叫做缓存击穿。

比较经典的例子是商品秒杀时，大量的用户在抢某个商品时，商品的key突然过期失效了，所有请求都到数据库上了。

##### 如何解决缓存击穿

- 热点key不设置过期时间，避免key过期失效
- 加锁，如果缓存失效的情况，只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求，防止数据库宕机，不过这样会导致系统的性能变差。

#### 缓存穿透

##### 什么是缓存穿透

缓存穿透是指用户的请求没有经过缓存而直接请求到数据库上了，比如用户请求的key在Redis中不存在，或者用户恶意伪造大量不存在的key进行请求，都可以绕过缓存，导致数据库压力太大挂掉。

##### 如何解决缓存穿透

- **参数校验**，例如可以对用户id进行校验，直接拦截不合法的用户的请求
- **缓存空值**，如果某个key在Redis中不存在，在数据库中也不存在，则将把这个Key值保存进Redis，设置value="null"。
- **布隆过滤器**，布隆过滤器可以**判断这个key在不在数据库中**，特点是**如果判断这个key不在数据库中，那么这个key一定不在数据库中，如果判断这个key在数据库中，也不能保证这个key一定在数据库中**。就是会有少数的漏网之鱼，造成这种现象的原因是因为布隆过滤器中使用了hash[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)，对key进行hash时，不同的key的hash值一定不同，但相同的hash的值不能说明这两个key相同。下面简单介绍下布隆过滤器，这个面试也常问。

布隆过滤器底层使用bit数组存储数据，该数组中的元素默认值是0。

布隆过滤器第一次初始化的时候，会把数据库中所有已存在的key，经过一系列的hash[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)计算，算出每个key的位置，并将该位置的值置为1，为了减少哈希冲突的影响，可以对每个key进行多次hash计算，如下图

![img](https://uploadfiles.nowcoder.com/files/20220228/115285789_1646044559427/0d6727bfa388c41d8114dc5ef760d804.png)

现在，用户所有的请求都要经过布隆过滤器过滤一遍，如果只有用户请求的key的hash值**都是1**才可以通过，否则直接拦截，如下图

![img](https://uploadfiles.nowcoder.com/files/20220228/115285789_1646044559444/f7011273e41405938c0d0dbe18c70f14.png)

那使用布隆过滤器就可以完美解决问题了吗？当然没有，使用布隆过滤器解决缓存穿透问题的同时也带来了一些其他问题：

1. 布隆过滤器存在误判的情况
2. 布隆过滤器不支持删除，因为布隆过滤器中存的1可能涉及多个key，直接删除可能会影响到其他key，比如上图第四个位置的1就涉及两个key
3. 如果数据库中数据更新同步到布隆过滤器时失败，布隆过滤器则会将本来正常的请求拦截住，这是非常致命的

先来看第一个问题，前面已经解释过了布隆过滤器存在误判的原因，**就是不同的key的hash值可能相同**。因为每个key要经过多次hash计算，恰好每次hash计算都和其他key的hash值相同的概率是很低的，有少数的漏网之鱼通过了布隆过滤器也不要紧，所以第一个问题不必担心。如果想要减少hash冲突导致的误判，可以适当增加key的hash次数。

第二个问题可以在布隆过滤器中以计数的方式存储，如下图

![img](https://uploadfiles.nowcoder.com/files/20220228/115285789_1646044559698/34875ac0e5e70b95bbba03ed7a8503b3.png)

上图中位置4被key1和key2的hash值覆盖，则为2，如果删除key2，则为下图

![img](https://note-java.oss-cn-beijing.aliyuncs.com/img/01ec86f293e7657f0a41c8f9f16714d1.png)

第三个问题出现概率不大，如果这种问题对业务影响很大，可以考虑其他解决缓存穿透的方法。